{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\n## <center>[2018 윈터코딩] 쿠키 구입</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - 각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때(오름차순 정렬)\n> - 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N)\n> - A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다\n> - 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return(조건에 맞지 않으면 0을 return)\n\n### 제안사항\n\n> - cookie의 길이는 1 이상 2,000 이하입니다.\n> - cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다.\n\n### 입출력 예\n\n> | cookie    | result |\n> | --------- | ------ |\n> | [1,1,2,3] | 3      |\n> | [1,2,4,5] | 0      |\n\n### 코드\n\n```javascript\nfunction solution(cookie) {\n  var answer = 0;\n  if (cookie.length <= 2) {\n    if (cookie.length == 2 && cookie[0] == cookie[1]) {\n      answer = cookie[0];\n    }\n    return answer;\n  }\n\n  //이분탐색\n  const len = cookie.length - 1;\n  for (\n    let i = 0;\n    i < len;\n    i++ //경계선\n  ) {\n    let presum = cookie[i]; //첫째 총 과자갯수\n    let preidx = i; //첫째 마지막에 추가한 바구니 위치\n    let postsum = cookie[i + 1]; //둘째 총 과자갯수\n    let postidx = i + 1; //둘째 마지막에 추가한 바구니 위치\n\n    //경계선을 기준으로 idx가 0 || len에 도달할때 까지\n    while (true) {\n      if (presum === postsum)\n        //첫째 과자갯수===둘째 과자갯수인 경우\n        answer = Math.max(presum, answer); //Max값인 경우에만 변수할당\n\n      if (preidx > 0 && presum <= postsum) {\n        //둘째 과자갯수가 더 많은 경우, idx가 0이 될때까지 과자의 총합을 더한다.\n        preidx--; //첫째 바구니 하나 더 추가\n        presum += cookie[preidx]; //첫째 과자갯수 총합에 더하기\n      } else if (postidx < len && presum >= postsum) {\n        //첫째 과자갯수가 더 많은 경우, idx가 len이 될때까지 과자의 총합을 더한다.\n        postidx++; //둘째 바구니 하나 더 추가\n        postsum += cookie[postidx]; //둘째 과자갯수 총합에 더하기\n      } //첫째 || 둘째의 바구니 위치가 0 || len에 도달한 경우 loop break\n      else break;\n    }\n  }\n  return answer;\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2018 윈터코딩 쿠키 구입 javascript 조건 각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때(오름차순 정렬) 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N) Ai 를 i…","fields":{"slug":"/algorithm-buycookie/"},"frontmatter":{"date":"Mar 20, 2020","title":"쿠키 구입(javascript)","tags":["알고리즘","프로그래머스","2018 윈터코딩"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2020 KAKAO BLIND RECRUITMENT] 괄호 변환</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다.\n> - 문자열 p를 이루는 '(' 와 ')' 의 개수는 항상 같습니다.\n> - 만약 p가 이미 올바른 괄호 문자열이라면 그대로 return 하면 됩니다.\n\n### 조건사항\n\n> - '(' 의 개수와 ')' 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.\n> - '('와 ')'의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.\n> - 예를 들어, \"(()))(\"와 같은 문자열은 균형잡힌 괄호 문자열 이지만 올바른 괄호 문자열은 아닙니다.\n> - 반면에 \"(())()\"와 같은 문자열은 균형잡힌 괄호 문자열 이면서 동시에 올바른 괄호 문자열 입니다.\n>\n> 1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.\n> 2. 문자열 w를 두 \"균형잡힌 괄호 문자열\" u, v로 분리합니다. 단, u는 \"균형잡힌 괄호 문자열\"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.\n> 3. 문자열 u가 \"올바른 괄호 문자열\" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.\n>    - 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.\n> 4. 문자열 u가 \"올바른 괄호 문자열\"이 아니라면 아래 과정을 수행합니다.\n>    - 빈 문자열에 첫 번째 문자로 '('를 붙입니다.\n>    - 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.\n>    - ')'를 다시 붙입니다.\n>    - u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.\n>    - 생성된 문자열을 반환합니다.\n\n### 입출력 예\n\n> | p          | result     |\n> | ---------- | ---------- |\n> | \"(()())()\" | \"(()())()\" |\n> | \")(\"       | \"()\"       |\n> | \"()))((()\" | \"()(())()\" |\n\n### 코드\n\n```javascript\nfunction solution(p) {\n  function solve(p)\n  {\n    if (p == \"\") //1. Logic 수행\n    return p;\n\n    let stack = []; //Stack을 사용하여 균형잡힌 괄호 문자열 분리\n    let u=\"\", v=\"\";\n    for (let i = 0; i < p.length; i++) //2. Logic 수행\n    {\n      const now_char = p.charAt(i); //현재 비교할 문자(자주 사용하는 Data의 경우 유지보수 측면을 위하여 변수로 담는다)\n      if (i == 0) //최초 수행 시 stack에 push한다\n        stack.push(now_char);\n      else\n      {\n        const pre_char = stack[stack.length - 1]; //stack에 마지막에 들어간 문자\n        //전제조건에서 '균형잡힌 괄호 문자열'인 경우까지만 나누면 되므로 '올바른 괄호 문자열'인지는 판단하지 않는다.\n        if (pre_char === now_char) //이전 문자와 현재 문자가 같은 경우 [\"(\" == \"(\"] or [\")\" == \")\"] stack에 push한다.\n          stack.push(now_char)\n        else //다른 경우는 [\"(\" != \")\"] or [\")\" != \"(\"]인 경우\n          stack.pop();\n\n        if (stack.length == 0) //괄호의 쌍이 맞게 나눈 경우(균형잡힌 괄호 문자열인 경우)\n        {\n          u = p.slice(0, i + 1);\n          v = p.slice(i + 1);\n          break;\n        }\n      }\n    }\n\n    if (u.charAt(0) === \"(\") //3. Logic 수행\n    {\n      return u + solve(v); //3-1. Logic 수행\n    }\n    else //4. Logic 수행\n    {\n      u = u.slice(1 , u.length - 1); //4-4. Logic에서 첫 번째, 마지막 문자 제거, 미리 문자열 자르기를하여 혹시 모를 예외방지\n      let temp = \"\"; //4-4. Logic에서 변환된 문자열을 담을 임시변수\n      //loop에서 i = 1, len = u.length - 1한 경우 예외발생 가능성 있음(문자열이 1인경우)\n      for (let i = 0; i < u.length; i++) //4-4. Logic에서 괄호 방향 뒤집는 loop\n      {\n        if (u.charAt(i) == \"(\")\n          temp += \")\";\n        else\n          temp += \"(\";\n      }\n      return \"(\" + solve(v) + \")\" + temp; //4-1. 4-2. 4-3. 4-4. 수행\n    }\n    return u + solve(v); //4-5. 수행\n  }\n\n  return solve(p);\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2020 KAKAO BLIND RECRUITMENT 괄호 변환 javascript 조건 p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p…","fields":{"slug":"/algorithm-bracketchange/"},"frontmatter":{"date":"Mar 19, 2020","title":"괄호 변환(javascript)","tags":["알고리즘","프로그래머스","2020 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## 함수 호출에 따른 this\n\nJavascript함수는 호출 될 때, 매개변수로 argument와 this를 암묵적으로 전달 받는다.\n\n- Javascript에서의 this는 호출 될 때 인자로 전달받는 구조이므로, 호출 방식에 따라 this에 바인딩할 객체가 동적으로 결정된다.\n- 스코프(Scope)에서는 함수를 선언할 때 결정되었지만, this는 함수는 호출할 때 결정된다.\n\n### 함수의 호출방식\n\n1. 함수 호출\n2. 메소드 호출\n3. 생성자 함수 호출\n4. apply, call, bind 호출\n\n### 함수 호출\n\n브라우저에서 전역객체는 window이다. 이러한 전역객체는 전역 스코프(Global Scope)를 갖는 전역변수를 프로퍼티로 소유한다. 따라서, 전역 영역에서 선언한 함수는 전역객체의 프로퍼티로 접근 가능한 전역 메소드이다.\n\n- 아래와 같이 echo라는 함수를 선언 시 echo는 전역 영역에서 선언되어 전역객체의 프로퍼티로 저장되어 echo()함수를 실행 시 전역객체의 프로퍼티를 호출한 것으로 this는 전역객체이다.\n\n  ```Javascript\n  function echo() {\n      console.log(this); //window\n  }\n\n  echo(); //window\n  window.echo(); //window\n  ```\n\n- 아래와 같이 내부 함수(`echo2`) 또는 함수 선언식(`echo3`)의 경우 echo함수의 property로 저장된 것이 아니므로 this는 전역 객체를 참조한다.\n\n  ```Javascript\n  function echo() {\n    console.log(this); //window\n    function echo2() {\n        console.log(this); //window\n    }\n    var echo3 = function () {\n        console.log(this); //window\n    }\n    echo2();\n    echo3();\n  }\n\n  echo();\n  ```\n\n- 이러한 this가 전역 객체를 바인딩하는 경우는 다음과 같다.\n  1. 전역 영역에서 선언한 함수\n  2. callback 함수\n  3. 메소드의 내부함수\n  4. 함수의 내부함수\n- 만약, 내부함수에서 this가 전역객체를 참조하는 것을 회피 하기 위해서는 다음과 같이 this를 저장한 변수를 객체내부에 저장하여 참조하는 방식으로 구현한다.\n\n```Javascript\nvar echoText = \"Global Echo\";\n\nvar obj = {\n    echoText : \"local Echo\",\n    echo : function () {\n        var pThis = this;\n\n        console.log(\"echo.this : \" + this); // obj\n        console.log(\"echo.echoText : \" + this.echoText); // local Echo\n        function ehoc2() {\n            console.log(\"echo2.this : \" + this); // window\n            console.log(\"echo2.echoText : \" + this.echoText); // Global Echo\n\n            console.log(\"pThis.this : \" + pThis); // obj\n            console.log(\"pThis.echoText : \" + pThis.echoText); // local Echo\n        }\n    }\n}\n\nobj.echo();\n```\n\n- 이러한 방식 외 apply, call, bind 메소드를 사용하여 this를 바인딩하는 방법이 존재한다.\n\n### 메소드 호출\n\n함수가 객체의 프로퍼티이면 메소드라고 지칭하며 해당 메소드를 호출 시 소유한 객체가 this에 바인딩 된다.\n\n```Javascript\nvar obj = {\n    echoText : \"object echo\",\n    echo : function() {\n        console.log(this);\n    }\n}\nobj.echo(); // obj\n```\n\n### 생성자 함수 호출\n\n함수를 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수라고 한다. 이러한 생성자 함수 호출 시 빈 객체를 생성하며 this는 새로 생성된 빈 객체를 가리키게 됩니다. 또한, 빈 객체의 프로토타입 객체의 경우 생성자 함수의 prototype 프로퍼티가 가르키는 객체가 됩니다.\n\n즉, 생성자 함수 호출의 경우 this는 자기자신이 됩니다.\n\n```Javascript\n// 생성자 함수\nfunction Person(name) {\n    this.name = name;\n}\n\nvar me = new Person('Lee');\nconsole.log(me); // Person {name: \"Lee\"} <-- this\n\n// new 연산자 없이 호출 시 일반함수로의 호출이므로, 반환값은 없으며 this의 경우 전역객체이다.\nvar you = Person('Kim');\nconsole.log(you); // undefined\nconsole.log(window.name); // Kim\n```\n\n### apply, call, bind 호출\n\n현재까지 this의 경우 함수가 호출되는 패턴에 의해 결정되었다. 이러한 암묵적인 결정대신 명시적인 결정이 되도록 해주는 방법이 apply, call, bind 메소드를 사용하는 것이다.\n\n- 3가지 메소드의 경우 Function.prototype 객체의 메소드이므로 모든 함수는 이를 호출 가능하다.\n\n#### apply, call\n\n호출하고자 하는 함수에 대하여 this를 인자로 넘기는 객체로 바인드하고 인자에 대해서는 아래와 같이 넘긴다.\n\n```Javascript\nvar Person = function (name) {\n    this.name = name;\n};\n\nvar foo = {};\n\n// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.\nPerson.apply(foo, ['name', 'name2', ...]); //인자를 배열로 전달\nPerson.call(foo, 'name', 'name2', ...); //인자를 하나씩 전달\n\nconsole.log(foo); // { name: 'name' }\n```\n\n#### bind\n\n호출하고자 하는 함수를 bind()로 호출 시 인자로 넘긴 this 값이 바인딩된 함수를 만들고 반환합니다.\n\n- 인자의 경우 call() 메소드와 같은 방식으로 인자를 전달합니다.\n\n```Javascript\nfunction fn() {\n    console.log(this);\n}\nvar obj = {\n    value: 5\n};\nvar boundFn = fn.bind(obj);\nboundFn(); // -> { value: 5 }\n```\n\n### 참고\n\n[this | PoiemaWeb](https://poiemaweb.com/js-this)\n\n[Function.prototype.bind()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\n","excerpt":"함수 호출에 따른 this Javascript함수는 호출 될 때, 매개변수로 argument와 this를 암묵적으로 전달 받는다. Javascript에서의 this는 호출 될 때 인자로 전달받는 구조이므로, 호출 방식에 따라 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Mar 18, 2020","title":"Javascript this","tags":["this","Javascript"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2020 KAKAO BLIND RECRUITMENT] 문자열 압축</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.\n> - ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다.\n> - 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.\n> - 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return\n\n### 제한사항\n\n> - s의 길이는 1 이상 1,000 이하입니다.\n> - s는 알파벳 소문자로만 이루어져 있습니다.\n\n### 입출력 예\n\n> | s                          | result |\n> | -------------------------- | ------ |\n> | \"aabbaccc\"                 | 7      |\n> | \"ababcdcdababcdcd\"         | 9      |\n> | \"abcabcdede\"               | 8      |\n> | \"abcabcabcabcdededededede\" | 14     |\n> | \"xababcdcdababcdcd\"        | 17     |\n\n### 코드\n\n```javascript\nfunction solution(s) {\n  let answer = s; //문자열 그대로 반환\n  const cut_len = s.length / 2; //문자열 길이 / 2까지만 압축가능\n  const str_len = s.length; //문자열 길이만큼 loop 돌면서 자르는 단위 증가\n\n  for (\n    let i = 1;\n    i <= cut_len;\n    i++ //문자열 n개 단위 자르기(1~s.length/2)\n  ) {\n    let temp_str = ''; //임시로 압축한 문자열 저장하는 변수\n    let cut_str = s.slice(0, i); //최초 n개 단위로 자른 문자\n    let count = 1; //최초 문자열 자를 시 count 1로 초기화\n\n    for (\n      let j = i;\n      j < str_len;\n      j += i //문자열 길이만큼 loop(i만큼 증가)\n    ) {\n      const str = s.slice(j, j + i);\n      if (cut_str == str) {\n        //기준이 되는 문자와 같은 경우\n        count++; //숫자 증가\n      } //n개만큼 자른 문자가 반복되지 않는 경우\n      else {\n        temp_str += count > 1 ? count + cut_str : cut_str; //count 갯수를 기준으로 압축 문자 or 기존 문자 저장\n        cut_str = str; //기준 문자열을 새로운 n개만큼 자른 문자로 대체\n        count = 1; //count 갯수 초기화\n      }\n    }\n\n    if (cut_str) {\n      //for-loop 후 마지막 문자에 대하여 추가적으로 반영\n      temp_str += count > 1 ? count + cut_str : cut_str;\n    }\n\n    if (answer.length > temp_str.length) {\n      //압축문자가 더 작은 경우에만 answer 갱신\n      answer = temp_str;\n    }\n  }\n\n  return answer.length;\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2020 KAKAO BLIND RECRUITMENT 문자열 압축 javascript 조건 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. ababcdcdababcdcd의 경우 문자를…","fields":{"slug":"/algorithm-compressstring/"},"frontmatter":{"date":"Mar 17, 2020","title":"문자열 압축(javascript)","tags":["알고리즘","프로그래머스","2020 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## 스코프(Scopre)\n\n어떠한 변수에 접근할 수 있는 범위\n\n- 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙\n- 만약, 스코프가 없다면 동일한 이름의 식별자는 1개만 존재가능\n- Javascript는 `렉시컬(지역) 스코프`를 사용, 함수를 `어디에 선언`하느냐에 따라 스코프가 결정. 호출 되는 시점과 무관\n\n### 스코프 구분\n\n- Javascript는 기본적으로 함수(function) 스코프를 가짐\n- ES6 문법인 let, const를 통해 블록(block) 스코프 형성 가능\n\n### 전역 스코프\n\n전역 스코프란? 함수 밖이나 `{}`밖에 선언되었을 때를 말한다.\n\n- 즉, 코드 어디에서든지 참조 가능한 것을 말한다.\n- 아래의 코드에서 echo()함수를 호출 시 함수 내에서 text변수를 호출하는데, 함수 스코프 안에서 text변수를 찾은 뒤 없으면 상위 스코프에서 찾게됩니다. 이를 스코프 체인(Scope Chain)이라고 합니다.\n\n  ```Javascript\n  /*전역 스코프*/\n  var text = \"Hello World!\"; //전역 변수\n  function echo() {\n    console.log(text); //전역 변수 text를 호출\n  }\n  console.log(text); //\"Hellow World!\"\n  echo(); //\"Hellow World!\"\n  ```\n\n- 위와 같이 전역 변수의 경우 global 객체에 변수가 저장되어, 타 라이브러리 사용 시 이름 중복문제 발생할 수도 있습니다.\n- Javascript의 경우 함수 스코프를 기본으로 가지기 때문에 만약, if문 안에 var로 선언된 변수가 있는 경우 전역 스코프를 가집니다.\n\n  ```Javascript\n  if (true) {\n    var text = \"Hello World!\"; //전역 변수\n  }\n  console.log(text); //\"Hellow World!\"\n  ```\n\n### 지역 스코프\n\n지역 스코프란 특정 부분에서만 사용 할 수 있는 것을 말합니다.\n\n- 이러한 지역 스코프의 경우 크게 2가지로 나뉘며 함수 스코프, 블럭 스코프라 합니다.\n\n  #### 함수 스코프\n\n  함수 안에서 선언한 식별자를 말하며 그 함수 내부에서만 사용가능 한 것을 말합니다.\n\n  - 만약, 전역과 지역에 동일한 이름의 2개의 변수가 존재 시 지역변수를 우선참조합니다.\n\n  ```Javascript\n  /*함수 스코프*/\n  function echo() {\n    var text = \"Hello World!\"; //지역 변수\n    console.log(text); //전역 변수 text를 호출\n  }\n  echo(); //\"Hello World!\"\n  console.log(text); //Uncaught ReferenceError: text is not defined\n\n  /*동일한 이름의 변수가 2개 존재 시*/\n  var text = \"global Hello World!\";\n  function echo() {\n    var text = \"local Hello World!\";\n    console.log(text); // \"local Hello World!\"\n  }\n  console.log(text); // \"global Hello World!\"\n  ```\n\n  #### 블록 스코프\n\n  중괄호(`{}`) 내부에서 `const`또는 `let`으로 변수를 선언 시 해당 변수의 경우 중괄호 블록내에서만 접근 할 수 있습니다.\n\n  ```Javascript\n  /*블록 스코프*/\n  if (true) {\n    var a = 1; //전역 변수\n    const b = 2; //블록 변수\n    let c = 3; //블록 변수\n    console.log(a); // 1\n    console.log(b); // 2\n    console.log(c); // 3\n  }\n\n  console.log(a); // 1\n  console.log(b); //Uncaught ReferenceError: b is not defined\n  console.log(c); //Uncaught ReferenceError: c is not defined\n  ```\n\n### 암묵적 전역\n\n함수안에서 선언되지 않은 변수에 값을 할당 시 전역 객체의 프로퍼티로 할당 됩니다. 또한, 변수가 아니라 프로퍼티로 추가됨으로 호스이스팅이 발생하지 않습니다.\n\n- 전역 변수는 delete로 삭제 불가, 전역 프로퍼티는 delete로 삭제 가능\n\n  ```Javascript\n  console.log(window.a); //undefined <- 호이스팅 발생\n  console.log(window.text); //ReferenceError: text is not defined <- 호이스팅 미발생\n\n  var a = 1; //전역 변수\n\n  function echo() {\n    //선언하지 않은 변수\n    text = \"Hello World!\"; //window.text로 property 추가 됨\n    console.log(text); //\"Hello World!\"\n  }\n\n  echo(); //\"Hello World!\"\n\n  console.log(window.a); //1\n  console.log(window.text); //\"Hello World!\"\n\n  delete a; //전역 변수임으로 삭제 X\n  delete text; //프로퍼티로 삭제 O\n\n  console.log(window.a); //1\n  console.log(window.text); //undefined\n  ```\n\n### 참고\n\n[Scope | PoiemaWeb](https://poiemaweb.com/js-scope)\n\n[[번역] 자바스크립트 스코프와 클로저(JavaScript Scope and Closures)](https://medium.com/@khwsc1/%EB%B2%88%EC%97%AD-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80-javascript-scope-and-closures-8d402c976d19)\n","excerpt":"스코프(Scopre) 어떠한 변수에 접근할 수 있는 범위 참조 대상 식별자(identifier…","fields":{"slug":"/Scope/"},"frontmatter":{"date":"Mar 16, 2020","title":"스코프(Scope)","tags":["Scope","스코프","Javascript"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2018 KAKAO BLIND RECRUITMENT][1차] 다트게임</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> 1. 다트 게임은 총 3번의 기회로 구성된다.\n> 2. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.\n> 3. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.\n> 4. 옵션으로 스타상(_) , 아차상(#)이 존재하며 스타상(_) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.\n> 5. 스타상(_)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(_)의 점수만 2배가 된다. (예제 4번 참고)\n> 6. 스타상(_)의 효과는 다른 스타상(_)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(\\*) 점수는 4배가 된다. (예제 4번 참고)\n> 7. 스타상(\\*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)\n> 8. Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.\n> 9. 스타상(\\*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.\n\n### 제한사항\n\n> - 점수는 0에서 10 사이의 정수이다.\n> - 보너스는 S, D, T 중 하나이다.\n> - 옵선은 \\*이나 # 중 하나이며, 없을 수도 있다.\n\n### 입출력 예\n\n> | 예제 | dartResult | answer | 설명                                                            |\n> | ---- | ---------- | ------ | --------------------------------------------------------------- |\n> | 1    | 1S2D\\*3T   | 37     | 1<sup>1</sup> \\* 2 + 2<sup>2</sup> \\* 2 + 3<sup>3</sup>         |\n> | 2    | 1D2S#10S   | 9      | 1<sup>2</sup> + 2<sup>1</sup> \\* (-1) + 10<sup>1</sup>          |\n> | 3    | 1D2S0T     | 3      | 1<sup>2</sup> + 2<sup>1</sup> + 0<sup>3</sup>                   |\n> | 4    | 1S*2T*3S   | 23     | 1<sup>1</sup> \\* 2 \\* 2 + 2<sup>3</sup> \\* 2 + 3<sup>1</sup>    |\n> | 5    | 1D#2S\\*3S  | 5      | 1<sup>2</sup> \\* (-1) \\* 2 + 2<sup>1</sup> \\* 2 + 3<sup>1</sup> |\n> | 6    | 1T2D3D#    | -4     | 1<sup>3</sup> + 2<sup>2</sup> + 3<sup>2</sup> \\* (-1)           |\n> | 7    | 1D2S3T\\*   | 59     | 1<sup>2</sup> + 2<sup>1</sup> \\* 2 + 3<sup>3</sup> \\* 2         |\n\n### 코드\n\n```javascript\nfunction solution(dartResult) {\n  //점수 - [정수][S|D|T]\n  //옵션 - * | # | \"\"\n  //Math.pow(x,y) x의 y제곱\n  let stack = []; //다트 점수를 넣을 배열(총 길이 : 3)\n  let score = { S: 1, D: 2, T: 3 }; //영역에 따른 제곱 수\n  let count = 0; //숫자 영역을 체크하기 위한 count 값(10인 경우)\n  const len = dartResult.length;\n\n  //dartResult길이만큼 loop\n  for (let i = 0; i < len; i++) {\n    let data = dartResult.charAt(i);\n    if (+data != data) {\n      //number로 변환 시 현재 text와 동일한지 판단(문자인 경우 NaN)\n      if (score[data]) {\n        //현재 문자가 영역인 경우\n        stack.push(Math.pow(dartResult.slice(i - count, i), score[data]));\n        count = 0;\n      } else {\n        const invariable = data === '*' ? 2 : -1; //스타상, 아차상에 따른 상수 설정\n        const len = stack.length; //자주 사용되는 점수배열의 길이 값을 변수로 할당\n        if (invariable == 2 && len > 1) {\n          //스타상인 경우 앞의 값도 2배를 해줘야함으로 현재 몇 번째 기회인지를 체크한다.\n          stack[len - 2] = stack[len - 2] * invariable;\n        }\n        stack[len - 1] = stack[len - 1] * invariable; //스타상, 아차상 둘 다 동일하게 현재 점수에 대하여 곱하기 연산 수행\n      }\n    } else {\n      count++; //숫자 영역 체크를 위한 카운트\n    }\n  }\n\n  return stack.reduce((acc, value) => acc + value, 0); //배열의 합 반환\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 다트게임 javascript 조건 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple…","fields":{"slug":"/algorithm-dartgame/"},"frontmatter":{"date":"Mar 15, 2020","title":"다트게임(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2019 KAKAO BLIND RECRUITMENT] 실패율</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - 실패율은 다음과 같이 정의한다.\n>   - 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수\n> - 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하라\n\n### 제한사항\n\n> - 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\n> - stages의 길이는 1 이상 200,000 이하이다.\n> - stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.\n>   - 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.\n>   - 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.\n> - 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.\n> - 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.\n\n### 입출력 예\n\n> | N   | stages                   | result      |\n> | --- | ------------------------ | ----------- |\n> | 5   | [2, 1, 2, 6, 2, 4, 3, 3] | [3,4,2,1,5] |\n> | 4   | [4,4,4,4,4]              | [4,1,2,3]   |\n\n### 코드\n\n```javascript\nfunction solution(N, stages) {\n  var answer = [];\n  var stack = [];\n  let users = stages.length;\n  //[] {stage, 실패율}\n  for (var i = 1; i <= N; i++) {\n    const len = stages.filter(value => value === i).length;\n    if (len === 0) {\n      stack.push({ index: i, ratio: 0 });\n    } else {\n      stack.push({ index: i, ratio: len / users });\n      users -= len;\n    }\n  }\n\n  stack.sort((a, b) => {\n    if (b.ratio === a.ratio) {\n      return a.index - b.index;\n    } else {\n      return b.ratio - a.ratio;\n    }\n  });\n\n  return stack.map(value => value.index);\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2019 KAKAO BLIND RECRUITMENT 실패율 javascript 조건 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N…","fields":{"slug":"/algorithm-failrate/"},"frontmatter":{"date":"Mar 15, 2020","title":"실패율(javascript)","tags":["알고리즘","프로그래머스","2019 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2018 KAKAO BLIND RECRUITMENT][1차] 비밀지도</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> 1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(\" ) 또는벽(#\") 두 종류로 이루어져 있다.\n> 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.\n> 3. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.\n> 4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\n\n### 제한사항\n\n> - 1 ≦ n ≦ 16\n> - arr1, arr2는 길이 n인 정수 배열로 주어진다.\n> - 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.\n\n### 입출력 예\n\n> | 매개변수 | 값                                          |\n> | -------- | ------------------------------------------- |\n> | n        | 5                                           |\n> | arr1     | [9, 20, 28, 18, 11]                         |\n> | arr2     | [30, 1, 21, 17, 28]                         |\n> | 출력     | [\"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\"] |\n\n> | 매개변수 | 값                                                         |\n> | -------- | ---------------------------------------------------------- |\n> | n        | 6                                                          |\n> | arr1     | [46, 33, 33 ,22, 31, 50]                                   |\n> | arr2     | [27 ,56, 19, 14, 14, 10]                                   |\n> | 출력     | [\"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \"] |\n\n### 코드\n\n```javascript\nfunction solution(n, arr1, arr2) {\n  var answer = [];\n  const len = arr1.length;\n\n  //arr1의 row개수(== n)만큼 loop\n  for (let i = 0; i < len; i++) {\n    //10진수 -> 2진수\n    let arr1_row = arr1[i].toString(2);\n    let arr2_row = arr2[i].toString(2);\n\n    //2진수로 변경 시 앞의 0이 제외된 부분 추가\n    if (arr1_row.length < n) {\n      arr1_row = '0'.repeat(n - arr1_row.length) + arr1_row;\n    }\n    if (arr2_row.length < n) {\n      arr2_row = '0'.repeat(n - arr2_row.length) + arr2_row;\n    }\n\n    //숫자 -> 문자(# || \" \")로 변경\n    let str_temp = '';\n    for (let j = 0; j < len; j++) {\n      if (Math.max(arr1_row.charAt(j), arr2_row.charAt(j)) == 1) str_temp += '#';\n      else str_temp += ' ';\n    }\n    answer.push(str_temp);\n  }\n  return answer;\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 비밀지도 javascript 조건 지도는 한 변의 길이가 n…","fields":{"slug":"/algorithm-screatmap/"},"frontmatter":{"date":"Mar 13, 2020","title":"비밀지도(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2018 KAKAO BLIND RECRUITMENT][1차] 캐시</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.\n>\n> - cache hit일 경우 실행시간은 1이다.\n>\n> - cache miss일 경우 실행시간은 5이다.\n\n### 제한사항\n\n> - 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.\n> - cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.\n> - cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.\n> - 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.\n\n### 입출력 예\n\n> | 캐시크기(cacheSize) | 도시이름(cities)                                                                          | 실행시간 |\n> | ------------------- | ----------------------------------------------------------------------------------------- | -------- |\n> | 3                   | [Jeju, Pangyo, Seoul, NewYork, LA, Jeju, Pangyo, Seoul, NewYork, LA]                      | 50       |\n> | 3                   | [Jeju, Pangyo, Seoul, Jeju, Pangyo, Seoul, Jeju, Pangyo, Seoul]                           | 21       |\n> | 2                   | [Jeju, Pangyo, Seoul, NewYork, LA, SanFrancisco, Seoul, Rome, Paris, Jeju, NewYork, Rome] | 60       |\n> | 5                   | [Jeju, Pangyo, Seoul, NewYork, LA, SanFrancisco, Seoul, Rome, Paris, Jeju, NewYork, Rome] | 52       |\n> | 2                   | [Jeju, Pangyo, NewYork, newyork]                                                          | 16       |\n> | 0                   | [Jeju, Pangyo, Seoul, NewYork, LA]                                                        | 25       |\n\n### 코드\n\n```javascript\nfunction solution(cacheSize, cities) {\n  var answer = 0;\n  let cache = [];\n\n  //LRU(페이지 교체 알고리즘) : 가장 마지막에 사용 된 페이지를 교체\n  const cities_len = cities.length;\n\n  if (cacheSize == 0) return cities_len * 5; //캐시크기가 0인 경우 전부 실행시간이 5이기 때문에 반환\n\n  //도시 개수만큼 loop\n  for (let i = 0; i < cities_len; i++) {\n    const citie = cities[i].toLowerCase(); //도시 이름\n    if (cache.indexOf(citie) !== -1) {\n      //cache hit\n      answer += 1; //1초 추가\n      cache.splice(cache.indexOf(citie), 1); //hit 된 도시 배열에서 제거\n      cache.push(citie); //가장 최근에 hit됨으로 마지막 index에 위치\n    } //cache miss\n    else {\n      if (cache.length < cacheSize) {\n        //cache max size 미 도달\n        cache.push(citie);\n      } //LRU Logic 실행\n      else {\n        cache.shift(); //가장 마지막에 사용된 페이지 제거\n        cache.push(citie); //새로운 페이지 추가\n      }\n      answer += 5;\n    }\n  }\n  return answer;\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 캐시 javascript 조건 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다. cache hit일 경우 실행시간은 1이다. cache miss일 경우 실행시간은…","fields":{"slug":"/algorithm-cache/"},"frontmatter":{"date":"Mar 12, 2020","title":"캐시(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## Fetch API 학습\n\n---\n\n### 개념\n\n- 기존 XMLHttpRequest(이하 XHR)를 대체하는 개념으로 Request나 Response를 포함하며 결과값으로 Promise객체를 반환합니다.\n- XHR에서 Response를 확인하기 위하여 callback이나 event를 사용하던 부분을 .then(), .catch()를 사용하여 확인합니다.\n- ajax와 유사해 보이지만 다른 부분이 존재\n  1. 결과값인 Promise 객체는 HTTP error 상태를 reject하지 않음\n     - Status Code가 404나 500인 경우 resolve처리. ok상태가 false인 resolve를 반환\n     - 네트워크 장애, 요청 미완료 시 reject 반환\n  2. 쿠키를 보내거나 받지 않음\n     - CORS 및 쿠키 사용시에는 Header에 credentials 속성을 설정해줘야 함\n- 미지원 브라우저의 경우 [Fetch Polyfill](https://github.com/github/fetch)사용하여 구현가능\n\n### 문법\n\n1.  Syntax\n\n    ```Javascript\n    fetch(URL, [option]);\n    //URL : 통신 요청할 서버주소\n    //option : 객체를 넘기며 method, headers, body... 와 같은 properyt를 설정한다.\n    ```\n\n2.  사용법\n\n    아래와 같이 URL을 입력 후 성공, 실패에 대한 동작정의를 then(), catch() 메소드를 사용하여 처리한다.\n\n    ```Javascript\n    fetch(URL, [option]);\n    //Get방식\n    fetch('http://example.com/movies.json') //서버 주소를 첫 번째 인자로 넘김\n    .then(res => console.log(res)) //통신 성공 시 수행 할 코드\n    .catch(err => console.log(err)); //error 발생 시 예외처리 할 코드\n\n    //Post방식\n    const option = {\n      method : \"POST\",\n      body : ...,\n      header : {}\n    }\n    fetch('http://example.com/movies.json', option) //두 번째 인자에 객체를 인자로 전달한다\n    .then(res => console.log(res)) //통신 성공 시 수행 할 코드\n    .catch(err => console.log(err)); //error 발생 시 예외처리 할 코드\n    ```\n\n### 관련 인터페이스\n\n1.  Headers\n\n    - Headers() 생성자를 사용해 헤더 객체를 생성가능\n    - Key와 Value로 이루어진 multi-map구조\n\n      ```Javascript\n      //1. set(), append() 메소드를 사용하여 property 추가\n      var myHeaders = new Headers();\n      myHeaders.set(\"Content-Type\", \"text/plain\"); //기존의 동일한 property가 존재시 덮어쓰기\n      myHeaders.append(\"Content-Length\", \"Hello World\".length.toString());\n      myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\");\n      //2. 생성자에 인자로 전달\n      myHeaders = new Headers({\n      \"Content-Type\": \"text/plain\",\n      \"Content-Length\": \"Hello World\".length.toString(),\n      \"X-Custom-Header\": \"ProcessThisImmediately\",\n      });\n\n      //3. has(), get(), getAll() 메소드로 value 확인\n      myHeaders.has(\"Content-Type\") // true\n      myHeaders.has(\"Set-Cookie\") // false\n      myHeaders.get(\"Content-Length\") // 11\n      myHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n      myHeaders.getAll(\"X-Custom-Header\") // [\"ProcessThisImmediately\", \"AnotherValue\"]\n\n      //4. delete()로 삭제\n      myHeaders.delete(\"X-Custom-Header\");\n      ```\n\n2.  Request\n\n    - fetch()에 직접 URL, option을 입력하는 것을 대체해준다.\n\n      ```Javascript\n      //Request(URL, [option])\n      //URL : 서버 주소\n      //option : method, headers, body... etc fetch의 두 번째 인자를 대체\n      const req = new Request(\"/api/posts\", {\n      method: \"GET\",\n      headers: new Headers({ //Headers 인터페이스 사용 or 직접 객체입력\n      \"content-type\": \"application/json\",\n      }),\n      body: { //Body 인터페이스로 대체 가능\n      name: \"LeeHanur\",\n      }\n      });\n\n      fetch(req)\n      .then(res => console.log(res))\n      .catch(err => console.log(err);\n      ```\n\n3.  Response\n\n    - fetch()에서는 resolve 됬을 때 Response 인스턴스를 반환한다.\n    - 생성자로 객체 생성하여 사용 가능하나 ServiceWorkers에서 사용할 것이 아니면 굳이 생성하지 않는다.\n\n      ```Javascript\n      //Response 상수\n\n      Response.status //HTTP Status의 정수치, 기본값 200\n      Response.statusText //HTTP Status 코드의 메서드와 일치하는 문자열, 기본값은 \"OK\"\n      Response.ok //HTTP Status 코드가 200~299 값 인지에 대하여 Boolean를 반환\n\n      var myResponse = new Response(body, [init]);\n      //body : null 허용, Blob|BufferSource... etc 응답된 body의 type을 정의\n      //init : status, statusText, headers 3가지 property 설정가능\n\n      var myBlob = new Blob();\n      var init = { \"status\" : 200 , \"statusText\" : \"SuperSmashingGreat!\" };\n      var myResponse = new Response(myBlob,init);\n      ```\n\n4.  body\n\n    - Request, Response 둘 다 Body를 가지고 있으며, body는 아래에서 기술한 타입들 중 하나의 인스턴스입니다.\n\n      - ArrayBuffer\n      - ArrayBufferView (Uint8Array같은 TypedArray)\n      - [Blob](https://developer.mozilla.org/ko/docs/Web/API/Blob)/File\n      - 문자열\n      - [URLSearchParams](https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams)\n      - [FormData](https://developer.mozilla.org/ko/docs/Web/API/FormData)\n\n      ```Javascript\n      var form = new FormData(document.getElementById('login-form'));\n      fetch(\"/login\", {\n      method: \"POST\",\n      body: form\n      })\n      ```\n\n### 참고\n\n- [Using Fetch](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Fetch%EC%9D%98_%EC%82%AC%EC%9A%A9%EB%B2%95)\n\n- [Javascript Fetch API](https://medium.com/@kkak10/javascript-fetch-api-e26bfeaad9b6)\n","excerpt":"Fetch API 학습 개념 기존 XMLHttpRequest(이하 XHR)를 대체하는 개념으로 Request나 Response를 포함하며 결과값으로 Promise객체를 반환합니다. XHR에서 Response를 확인하기 위하여 callback…","fields":{"slug":"/fetch API/"},"frontmatter":{"date":"Mar 11, 2020","title":"fetch API","tags":["fetch","Javascript"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2018 KAKAO BLIND RECRUITMENT][3차] 파일명 정렬</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.\n>\n> - 각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(\" ), 마침표(.), 빼기 부호(-\")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.\n>\n> - 중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.)\n\n### 제한사항\n\n> 파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다.\n>\n> - HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.\n> - NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다.\n> - TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.\n>\n> | 파일명           | HEAD | NUMBER | TAIL        |\n> | ---------------- | ---- | ------ | ----------- |\n> | foo9.text        | foo  | 9      | .txt        |\n> | foo010bar020.zip | foo  | 010    | bar020.zip  |\n> | F-15             | F-   | 15     | (빈 문자열) |\n>\n> 파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.\n>\n> - 파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. MUZI와 muzi, MuZi는 정렬 시에 같은 순서로 취급된다.\n> - 파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 < 10 < 0011 < 012 < 13 < 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.\n> - 두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. MUZI01.zip과 muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.\n\n### 입출력 예\n\n> 입력: [img12.png, img10.png, img02.png, img1.png, IMG01.GIF, img2.JPG]\n>\n> 출력: [img1.png, IMG01.GIF, img02.png, img2.JPG, img10.png, img12.png]\n\n> 입력: [F-5 Freedom Fighter, B-50 Superfortress, A-10 Thunderbolt II, F-14 Tomcat]\n>\n> 출력: [A-10 Thunderbolt II, B-50 Superfortress, F-5 Freedom Fighter, F-14 Tomcat]\n\n### 코드\n\n```javascript\nfunction solution(files) {\n  let answer = [];\n  //HEAD, NUMBER, TAIL 구분\n  //NUMBER를 기준으로 앞/뒤 구분 search(정규식)\n  let len = files.length;\n  const reg = /(\\d+)/g; //숫자가 1개이상 매칭되는 정규식(메모리 고려)\n  for (let i = 0; i < len; i++) {\n    answer.push({ index: i, value: files[i].split(reg) }); //[{index:0~n, value:[HEAD, NUMBER, TAIL]}]\n  }\n\n  //sort의 0은 유지 but ECMAscript 명세에 따라 보장은 하지않음(index로 순서보장)\n  answer.sort((a, b) => {\n    //HEAD의 값을 비교\n    const a_head = a.value[0].toLowerCase();\n    const b_head = b.value[0].toLowerCase();\n    if (a_head < b_head) return -1;\n    else if (a_head > b_head) return 1;\n    else {\n      //HEAD가 같은경우 NUMBER를 비교\n      const a_number = Number(a.value[1]); //Number로 앞의 0을 제거\n      const b_number = Number(b.value[1]);\n      if (a_number > b_number) return 1;\n      else if (a_number < b_number) return -1;\n      else {\n        //HEAD, NUMBER가 같은 경우 index로 순서보장\n        if (a.index < b.index) return -1;\n        else return 1;\n      }\n    }\n  });\n\n  return answer.map(obj => obj.value.join(''));\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 파일명 정렬 javascript 조건 files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다. 각 파일명은 10…","fields":{"slug":"/algorithm-filename-sort/"},"frontmatter":{"date":"Mar 10, 2020","title":"파일명 정렬(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## window.open()시 width, height값이 설정한 값과 다른 현상\n\n- window의 내장함수인 open()을 사용 시 브라우저별로 값이 다르게 나타나는 현상\n\n### 문법\n\n```javascript\nwindow.open(URL, name, specs, replace);\n```\n\n- specs에 \"width=pixels\", \"height=pixels\"값을 입력하여 크기를 설정 가능합니다.\n\n```javascript\nwindow.resizeTo(aWidth, aHeight);\n```\n\n- aWidth, aHeight 설정 시 window의 outerWidth, outerHeight값이 설정한 값으로 변경됩니다.\n\n### 현상\n\n- 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\n  ([**샘플**](https://angwangho.github.io/sampleFile/window_method/open_main.html))\n\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/window_method/open_main.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n- 최초 확인 시 IE11, Edge, chorme(win10/win8), Opera 브라우저에서 설정한 값과 다르게 크기가 설정되는 것을 확인하였습니다.(2019.11.20기준)\n  - window open() 시 window의 innerWidth,innerHight값이 specs에서 설정한 width, height값과 같아야 합니다.\n- window.resizeTo() 함수 사용 시 Edge 브라우저에서 값이 다르게 설정 됩니다.\n\n### 해결방안\n\n1. 변경 후 값 재보정\n   - 얼만큼 잘못된 값이 설정될지는 실행 전 알 수 없습니다.\n   - 이에 대하여 설정 된 후 보정을 통하여 원하는 값으로 설정되도록 합니다.\n     - resize event에서 설정 값, outer/inner의 차이를 통해 값 보정\n","excerpt":"window.open()시 width, height값이 설정한 값과 다른 현상 window의 내장함수인 open()을 사용 시 브라우저별로 값이 다르게 나타나는 현상 문법 specs에 \"width=pixels\", \"height=pixels…","fields":{"slug":"/open-Bug/"},"frontmatter":{"date":"Mar 09, 2020","title":"window.open()시 width, height값이 설정한 값과 다른 현상","tags":["open","window.open","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\n## window의 내장함수인 alert()을 사용 시 브라우저별로 script 처리 및 event가 다른 현상\n\n### 문법\n\n```javascript\nwindow.alert([message]) | alert([message]);\n//message에 경고 대화상자 창에 표시할 텍스트를 입력합니다.\n```\n\n### 현상\n\n- 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\n  ([**샘플**](https://angwangho.github.io/sampleFile/window_method/alert.html))\n\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/window_method/alert.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n- mousedown event에서 alert()을 실행 시 브라우저 별 event 발생이 다르며 script 처리 방식에 차이가 존재합니다.\n\n  - IE11, Edge와 같이 OS, 브라우저 버전에 따라 차이가 존재합니다.\n\n- 브라우저별 확인 결과 크게 3가지로 분류가 가능합니다.\n  1. event 미발생 : mouseup event가 발생 X\n     - chrome, IE11(win7)\n  2. event 발생 : alert 실행 중 mouseup event가 발생\n     - IE11(win10), Edge(18)\n     - Edge(18)의 경우 mouseup event가 발생하나 alert, confirm를 실행 시 해당 동작이 수행되지 않습니다.\n  3. event block 후 발생 : alert 창이 닫힌 후 event 발생\n     - FireFox\n\n### 해결방안\n\n1. 실행 시점 변경\n   - alert 발생 시 창이 닫혔는지 알 수 있는 방안이 없으며, 브라우저 별 script처리 및 event 발생 차이가 존재\n   - 실행 시점을 mouseup, click event으로 변경하여 호출\n","excerpt":"window의 내장함수인 alert()을 사용 시 브라우저별로 script 처리 및 event가 다른 현상 문법 현상 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\n(샘플) mousedown event에서 alert…","fields":{"slug":"/alert-Bug/"},"frontmatter":{"date":"Mar 08, 2020","title":"alert 사용 시 브라우저별 script처리 및 event가 다른 현상","tags":["alert","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\n## React.js에 typescript 적용하기\n\n---\n\n- React 공식 사이트를 참고하여 진행하였습니다.\n\n  [Static Type Checking - React](https://ko.reactjs.org/docs/static-type-checking.html#using-typescript-with-create-react-app)\n\n### 프로젝트 설치\n\n- 생성하고자하는 위치에서 프로젝트이름을 원하는 이름으로 넣은 후 아래 명령어를 터미널에서 입력한다.\n\n  ```Shell\n    npx create-react-app '프로젝트이름' --template typescript\n  ```\n\n- 만약, app.js 즉, 기본 실행 페이지가 없으며 아래와 같은 text가 발생한 경우\n\n  > template was not provided. This is likely because you're using an outdated version of create-react-app.\n  > Please note that global installs of create-react-app are no longer supported.\n\n- 아래 명령어를 실행하여 global로 설치된 react-app을 제거 후 시작한다.\n\n  ```Shell\n    npm uninstall -g create-react-app\n  ```\n\n- 만약, Mac 환경에서 src가 생성이 안된 경우는 다음과 같이 명령어를 실행 후 생성된다\n\n  ```Shell\n  npm rm -g create-react-app #old 버전 제거\n  sudo npm install -g create-react-app #sudo로 해야 권한 에러 미발생\n  ```\n\n- 정상적으로 설치 시 아래와 같은 디렉토리 구조를 가진다.\n\n  ![Alternate text][directory]\n\n- 아래 명령어를 입력하여 프로젝트를 실행한다.\n\n  ```Shell\n  cd '프로젝트이름'\n  npm start\n  ```\n\n  - 실행 시 다음과 같은 화면을 확인할 수 있다.👏\n\n    ![Alternate text][runview]\n\n### 실행 및 테스트\n\n- typescript가 적용되고 있는지 간단히 확인하기 위하여 Header.tsx라는 파일을 생성하여 다음과 같은 코드를 작성\n\n  ```javascript\n  //Header.tsx\n  import React from \"react\";\n\n  function Header(props: { title: string }) {\n  const test = parseInt(props.title, 10) as Number; // or const test: Number = parseInt(props.title, 10)\n  return <div>{test}</div>;\n  }\n\n  export default Header;\n\n  //App.tsx\n  import React from \"react\";\n  import \"./App.css\";\n  import Header from \"./Header\";\n\n  function App() {\n  return (\n\n  <div className=\"App\">\n  <header className=\"App-header\">\n  <Header title=\"1234\" />\n  </header>\n  </div>\n  );\n  }\n\n  export default App;\n  ```\n\n- App.tsx에서 기존의 태그들을 삭제 후 Header라는 함수형 컴포넌트에 title property에 값을 넣어 typescript를 테스트하고자 합니다.\n\n- 현재, 코드상 title에 string값을 인자로 넘겨주고 있습니다. 만약, string이 아닌 값을 넣어 줄 시 tool상에서 다음과 같은 error를 표시합니다.\n\n  ![Alternate text][syntax_error]\n\n- 다시 원래대로 문자열을 넘겨주도록 되돌린 후 실행 시 다음과 같이 적용된 것을 확인 할 수 있습니다.\n\n  ![Alternate text][updateview]\n\n- typescript 사용시 자세한 문법이나 type의 경우 다음 링크를 참조하여 작업하기 바랍니다.\n\n  [TypeScript 한글 문서](https://typescript-kr.github.io/pages/Basic%20Types.html)\n\n[directory]: image1.png '폴더구조'\n[runview]: image2.png '실행결과'\n[syntax_error]: image3.png '문법에러'\n[updateview]: image4.png '수정결과화면'\n","excerpt":"React.js에 typescript 적용하기 React 공식 사이트를 참고하여 진행하였습니다. Static Type Checking - React…","fields":{"slug":"/React-typescript.md/"},"frontmatter":{"date":"Mar 07, 2020","title":"React.js에 typescript 적용하기","tags":["React.js","typescript"]}}},{"node":{"rawMarkdownBody":"\n## React.js의 Hook에 대해서 학습 및 사용법\n\n---\n\n- 학습의 경우 공식 홈페이지를 참고하여 진행([**공식홈페이지**](https://ko.reactjs.org/docs/hooks-intro.html)).\n- React 버전 16.8.0이상, React Native 0.59이상에서 지원\n\n### 등장 배경\n\n- 기존 React에서 state를 사용하기 위해서는 class형태에서 React.component를 상속하여 사용\n- 상속 없이 import 방식으로 Function이나 const같은 함수에서 state 사용할 수 있도록 지원하는 개념\n- 함수 컴포넌트에서 React state와 생명주기 기능(lifecycle features)을 “연동(hook into)“할 수 있게 해주는 함수.\n\n### 개념\n\n- state를 사용하기 위해 class를 사용하는데 이를 대체하여 class가 아니여도 state관리 및 rife-cycle사용이 가능하게 해주는 API\n- 좀 더 재사용 가능한 컴포넌트를 작성하는데 도움을 주기 위해 나옴\n- class안에서는 동작하지 않음\n\n### 문법\n\n- 중복하여 사용 가능(state, effect 동일)\n\n1.  State Hook\n\n    - state를 대체하는 개념으로 useState를 react로 부터 import하여 사용\n\n    - useState는 2개의 항목을 가지는 배열을 반환. 인자로 주는 값의 경우 초기 변수 값을 나타낸다.\n\n      > 💡 return [현재 변수값, 변수를 바꾸는 setter 함수];\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      import React, { useState } from 'react'; //useState가 hook\n\n      function Example() {\n        // \"count\"라는 새 상태 변수를 선언합니다\n        const [count, setCount] = useState(0); //useState는 중복하여 호출가능(각자 독립된 state를 가짐)\n        const [fruit, setFruit] = useState('banana');\n        const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n\n        return (\n          <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>Click me</button>\n          </div>\n        );\n      }\n      ```\n\n      </details>\n\n2.  Effect Hook\n\n    - 'Data를 가져와 DOM을 수정하는 작업'을 'side effects' or 'effects'라고 한다. 이러한 작업들을 함수 컴포넌트에서 Hook을 사용해서 수행 가능하도록 하는 것을 말한다.\n\n    - class의 생명주기 함수에서 제공되는 부분들에 대해서 제공하는 것(componentDidMount, componentDidUpdate, componentWillUnmount를 대체)\n\n    - props, state에 접근이 가능하며, 매 랜더링 후 실행 됨(최초 로딩 포함)\n\n    - 기존 class 구조에서는 생명주기 메서드 각각에 로직을 작성했으나 Effect Hook에서는 한 곳에서 로직관리 가능\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      import React, { useState, useEffect } from 'react';\n\n      function Example() {\n        const [count, setCount] = useState(0);\n\n        // componentDidMount, componentDidUpdate와 비슷합니다\n        useEffect(() => {\n          // 브라우저 API를 이용해 문서의 타이틀을 업데이트합니다\n          document.title = `You clicked ${count} times`; //DidMount, DidUpdate를 대체\n\n          return () => {\n            //willUnmount를 대체\n            //cdoe...\n          };\n        });\n\n        return (\n          <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>Click me</button>\n          </div>\n        );\n      }\n      ```\n\n      </details>\n\n    - 구독을 계속 갱신,취소하는데 이는 과도한 비용을 초래합니다. 이를 방지하고자 값이 변경 됬을 때만 새로운 구독을 생성하면 되는데 useEffect 두 번째 인자를 전달하여 사용할 것(props.source)\n\n      ```javascript\n      useEffect(\n        () => {\n          const subscription = props.source.subscribe();\n          return () => {\n            subscription.unsubscribe();\n          };\n        },\n        [props.source] //Option : [] 값 입력 시 DidMount/WillUnmount효과, 값이 있는 경우 변경 된 경우에만 코드 수행\n      );\n      ```\n\n3.  Context Hook\n\n    - context 객체(React.createContext에서 반환된 값)을 받아 그 context의 현재 값을 반환합니다. context의 현재 값은 트리 안에서 이 Hook을 호출하는 컴포넌트에 가장 가까이에 있는 <MyContext.Provider>의 value prop에 의해 결정됩니다.\n    - react.js의 context를 hook API화 시킨 개념\n\n      **Context란?**\n\n      - 하위 컴포넌트에 값을 전달하기 위해서는 props를 사용하여 넘겨주어야 하는데, 이를 사용하지 않고 값을 전달 가능하게 하는 기능\n      - 전역변수를 사용하는것과 비슷하지만, JS의 클로저를 활용하는 개념과 유사하다고 본다.\n      - 만약 상위에 Context가 있고 하위에서 Context를 선언할 시 하위의 Context를 참조함\n      - Context를 사용 시 따로 지정된 context를 참조하는게 아니라 문맥상 가장 가까운 위치의 context를 참조하기 때문에 만약, 하위에서 context를 사용 시 이를 참조하게 된다.\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      //React.createContext(Context 생성)\n      const MyContext = React.createContext(defaultValue); //defaultValue : Provider를 찾지 못하였을 때 사용\n\n      //Context.Provider : Notiy역활 수행\n      <MyContext.Provider value={/* 어떤 값 */}/>; //value가 변경된 것을 알리는 역활(re-rendering 수행)\n\n      //Context.Consumer : 구독 역활 수행\n      <MyContext.Consumer>\n        {value => /* context 값을 이용한 렌더링 */} //value를 구독\n      </MyContext.Consumer>\n      ```\n\n      </details>\n\n4.  Custom Hook\n\n    - 상태관련 Logic을 컴포넌트 간 재사용하고 싶은데 고전적인 방식으로는 higher-order components와 render props 2가지 방식을 사용\n    - Custom Hook은 이를 대체\n    - 이름의 경우 'useOOO'과 같이 앞에 use를 붙여서 사용 시 linter 플러그인 사용 시 버그를 찾아준다.\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      import React, { useState, useEffect } from 'react';\n\n      function useFriendStatus(friendID) {\n        const [isOnline, setIsOnline] = useState(null);\n\n        function handleStatusChange(status) {\n          setIsOnline(status.isOnline);\n        }\n\n        useEffect(() => {\n          ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n          return () => {\n            ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n          };\n        });\n\n        return isOnline;\n      }\n\n      //각 함수에서 독립되게 호출되어 사용됨\n      function FriendStatus(props) {\n        const isOnline = useFriendStatus(props.friend.id);\n\n        if (isOnline === null) {\n          return 'Loading...';\n        }\n        return isOnline ? 'Online' : 'Offline';\n      }\n\n      function FriendListItem(props) {\n        const isOnline = useFriendStatus(props.friend.id);\n\n        return <li style={{ color: isOnline ? 'green' : 'black' }}>{props.friend.name}</li>;\n      }\n      ```\n\n      </details>\n\n### 규칙\n\n1. 최상위 에서만 호출해야함. 반복문, 조건문, 중첩된 함수에서는 사용 X\n\n   - useState, useEffect가 여러번 호출되어 Hook보장을 위해서 최상위에서만 쓰라는 것\n\n   - 작성한 순서대로 react는 읽어들임(순서보장)\n\n2. Custom Hook이 아닌 이상, React 함수 컴포넌트에서만 호출할 것\n\n### 기타\n\n1. useEffect vs useLayoutEffect\n   - useEffect는 브라우저 화면이 다 그려질때 까지 지연, 다음 렌더링이 발생하기 전에 발생하는 것을 보장. 레이아웃 배치&그리기 완료 후 발생\n   - 이를 대체하기 위해 useLayoutEffect가 존재, 이는 모든 DOM변경 후 동기적으로 발생. 브라우저가 화면 그리기 이전에 동기적으로 발생\n     - componentDidMount나 componentDidUpdate와 동일한 단계를 실행하게 된다는 것에 주의\n   - 먼저 useEffect사용 후 문제 시 useLayoutEffect 사용할 것, 서버 렌더링 단계에서는 모든 js다운 전까지 둘다 실행 되지 않는다.\n     - UI가 깨져보일 수 있는 것들은 조건부 렌더링이나 노출 지연할 것\n","excerpt":"React.js의 Hook에 대해서 학습 및 사용법 학습의 경우 공식 홈페이지를 참고하여 진행(공식홈페이지). React 버전 16.8.0이상, React Native 0.59이상에서 지원 등장 배경 기존 React에서 state…","fields":{"slug":"/React js Hook/"},"frontmatter":{"date":"Mar 06, 2020","title":"React.js Hook","tags":["React.js","Hook"]}}},{"node":{"rawMarkdownBody":"\n## JSP에서 Github autopush 환경 만들기\n\n### 개발환경\n\n- Server : Tomcat8\n- OS : window10\n\n### 구현\n\n- DB에 Data가 갱신될 때 마다 Github 저장소에 auto push 기능을 구현하고자 하였다.\n- 이를 위해서 우선적으로 bat파일을 만들어 jsp환경에서 성공적으로 DB에 Update 시 실행하도록 하였다.\n\n  <details>\n  <summary>batch 파일 코드</summary>\n\n  ```Shell\n    F: #batch파일이 존재하는 드라이브 위치\n    cd 'batch가 위치할 폴더 경로' #batch 파일이 위치 할 폴더 경로\n    git add . #git에 변경된 사항에 대해서 스테이징 한다.\n    git commit -m \"auto push(file upload)\" #commit실행\n    git push origin master #git 저장소에 push\n  ```\n\n</details>\n\n- jsp에서 Runtime의 exec함수를 사용하여 batch파일을 실행하도록 코드를 작성하였다.\n\n  ```java\n  <%@ page import=\"java.lang.Runtime\"%> //Runtime import\n\n  Process process = Runtime.getRuntime().exec(\"파일경로\");\n  process.waitFor(); //batch파일이 실행되기 까지 대기\n\n  //Option : 실행 결과에대해서 알고 싶은 경우 구현\n  BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n\n  String line = null;\n\n  while((line = br.readLine()) != null){\n      out.println(line);\n  }\n  br.close();\n  //Option 끝\n\n  process.destroy(); //완료된 프로세스 제거\n  ```\n\n### 이슈\n\n- batch파일을 터미널에서 실행 시 정상적으로 수행되었으나 jsp코드 상 실행 시 무한 loop가 걸리는 문제가 존재하였다. 이에 대하여 line별 실행 해본 결과 push과정에서 문제가 발생하였다.\n- 이와 관련된 문제를 찾아본 결과 권한 문제. 즉, 로그인 문제인걸로 방향을 잡고 SSH keys를 발급하여 GitHub 계정에 등록하였다. 그러나 문제가 해결되지 않았다.\n- 이와 관련된, 문제에 대해서 찾아도 나오지 않아 프로젝트 문제인걸로 방향을 잡고 새로운 저장소를 생성하여 실행하였으나 결과는 같았다. 그때, 실수로 branch를 새로 생성하였는데 이 후로 push 실행 시 수행되는 것을 확인하였다!😮\n- SSH Keys를 발급 후 push를 수행한 경우 자동적으로 권한 취득이 되어 아이디/패스워드 미입력이 되는줄 알았는데 아니었나보다...\n- 만약, 이와 같은 증상을 겪는사람이 있다면 SSH Keys등록 후 브랜치를 하나 생성해보길 바란다.\n\n### 참고 사이트\n\n- [Pushing to Git returning Error Code 403 fatal: HTTP request failed](https://stackoverflow.com/questions/7438313/pushing-to-git-returning-error-code-403-fatal-http-request-failed)\n","excerpt":"JSP에서 Github autopush 환경 만들기 개발환경 Server : Tomcat8 OS : window10 구현 DB에 Data가 갱신될 때 마다 Github 저장소에 auto push 기능을 구현하고자 하였다. 이를 위해서 우선적으로 bat…","fields":{"slug":"/JSP batch/"},"frontmatter":{"date":"Mar 04, 2020","title":"JSP에서 batch 실행하기","tags":["JSP","batch","github","autopush"]}}},{"node":{"rawMarkdownBody":"\n## split()함수에 Regex를 사용 시 \"\"값이 return되지 않는 문제\n\n고객이 네트워크 속도 문제로 인해 필요없는 파일을 load하지 않기로 하였다. 이에 대해서 특정 js파일을 load제외하였는데 그로인해 IE8에서 textsize를 계산할 때 다른점이 발견되었다. 이러한 부분을 조사 중 IE8에서 split()에 정규식 공백문자(\" \")를 사용 시 반환되는 배열에 empty string(\"\")값이 제외되는 문제가 발생하였다.\n\n<details>\n<summary>💡 String.split() syntax</summary>\n\n```javascript\nString.split([separator[, limit]])\nseparator : 끊을 문자 or 정규식\nlimit : 몇 개 까지 자를 지에 대한 숫자\n```\n\n</details>\n\n만약 \" ab c d e fg 123 \"와 같은 문자열이 있다고 하자. 이 문자열에 대하여 \" \" 공백문자를 기준으로 자르고자 한다. 그렇다면 split()함수에 \" \"공백을 인자로 사용 시 \"\"을 포함한 배열이 반환 될 것이다. 근데, 만약 정규식을 사용 한다면 어떻게 될까?\n\n보통 정규식을 사용 시 다음과 같이 사용을 할 것이다\n\n```javascript\nvar reg = /abc/;\nvar reg = new RegExp('abc');\n```\n\n두 방식의 차이는 컴파일 시점의 차이로 첫 번째 방식의 경우 스크립트가 load되는 시점에 컴파일 되며 두 번째의 경우는 정규식이 실행되는 시점에 컴파일 된다. 만약, 상수와 같이 고정된 조건에 대해서 사용하는 경우 첫 번째 방식을 사용하며, 조건이 변경되는 경우는 두 번째 방식을 사용하면 될 것이다.\n\n### 테스트\n\n실행결과의 경우 아래에서 확인 가능하며, 해당 파일은 GitHub 저장소에 업로드되어있다.([**저장소**](https://github.com/AnGwangHo/sampleFile))\n\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/window_method/split.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n위 샘플에서 확인하였듯이 split()에 정규식을 사용하게 된다면 아래와 같이 empty stirng이 제외된 결과가 나올 것이다.\n\n```javascript\n//IE8 이하\n'   ab c d e   fg 123   '.split(' '); //[\"\", \"\", \"\", \"ab\", \"c\", \"d\", \"e\", \"\", \"\", \"fg\", \"123\", \"\", \"\", \"\"]\n'   ab c d e   fg 123   '.split(/\\s/); //[\"ab\", \"c\", \"d\", \"e\", \"fg\", \"123\"]\n```\n\n위 방식의 경우 동일하게 스페이스 문자를 기준으로 자르도록 하였다. 그러나 결과는 다르게 발생되었다. 문자열로 공백 문자를 인자로 준 경우 empty string값이 포함되어 배열이 반환되었으나 정규식을 사용한 경우 \"\"인 값들이 제외되고 배열이 반환되었다. 이를 해결하고자 다음과 같은 방안을 세우고 시도를 해보았다.\n\n### 해결방안\n\n1. ~~new RegExp(\"\\\\s\")를 사용~~\n   - \"\"값이 제외되어 반환\n2. ~~정규식 문법을 수정~~\n   - 다양한 방법으로 조건을 변경하였으나 \"\"값이 제외되어 반환되었다.  \n     ex) /(\\s)/, /[\\s\\xA0]/, / /g, /[ \\f\\n\\r\\t\\v]/, /\\u0020/(공백문자 유니코드)\n\n위와 같은 해결방안을 세우고 시도하였으나 \"\"값이 제외되고 반환되었다. 따로 해결이 가능한 부분이 없었으며 다음과 같은 결론을 내렸다.\n\n### 처리결과\n\n우선적으로 고객이 제외한 js파일에서 String.split함수에 대해서 오버라이딩이 되어있어 IE8이하에서 split(/\\s/)시 \"\"값이 포함된 배열이 반환되었다. 이러한 부분에 대해서 고객에게 split함수에 대해서 오버라이딩된 코드를 적용하도록 가이드하였다. 만약, 외부에서 IE8이하 브라우저를 지원해야하는 경우가 존재한다면 아래의 코드를 적용하면 된다.\n\n<details><summary>코드</summary>\n\n```javascript\n/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nvar split;\n\n// Avoid running twice; that would break the `nativeSplit` reference\nsplit =\n  split ||\n  (function(undef) {\n    var nativeSplit = String.prototype.split,\n      compliantExecNpcg = /()??/.exec('')[1] === undef, // NPCG: nonparticipating capturing group\n      self;\n\n    self = function(str, separator, limit) {\n      // If `separator` is not a regex, use `nativeSplit`\n      if (Object.prototype.toString.call(separator) !== '[object RegExp]') {\n        return nativeSplit.call(str, separator, limit);\n      }\n      var output = [],\n        flags =\n          (separator.ignoreCase ? 'i' : '') +\n          (separator.multiline ? 'm' : '') +\n          (separator.extended ? 'x' : '') + // Proposed for ES6\n          (separator.sticky ? 'y' : ''), // Firefox 3+\n        lastLastIndex = 0,\n        // Make `global` and avoid `lastIndex` issues by working with a copy\n        separator = new RegExp(separator.source, flags + 'g'),\n        separator2,\n        match,\n        lastIndex,\n        lastLength;\n      str += ''; // Type-convert\n      if (!compliantExecNpcg) {\n        // Doesn't need flags gy, but they don't hurt\n        separator2 = new RegExp('^' + separator.source + '$(?!\\\\s)', flags);\n      }\n      /* Values for `limit`, per the spec:\n       * If undefined: 4294967295 // Math.pow(2, 32) - 1\n       * If 0, Infinity, or NaN: 0\n       * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n       * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n       * If other: Type-convert, then use the above rules\n       */\n      limit =\n        limit === undef\n          ? -1 >>> 0 // Math.pow(2, 32) - 1\n          : limit >>> 0; // ToUint32(limit)\n      while ((match = separator.exec(str))) {\n        // `separator.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0].length;\n        if (lastIndex > lastLastIndex) {\n          output.push(str.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for\n          // nonparticipating capturing groups\n          if (!compliantExecNpcg && match.length > 1) {\n            match[0].replace(separator2, function() {\n              for (var i = 1; i < arguments.length - 2; i++) {\n                if (arguments[i] === undef) {\n                  match[i] = undef;\n                }\n              }\n            });\n          }\n          if (match.length > 1 && match.index < str.length) {\n            Array.prototype.push.apply(output, match.slice(1));\n          }\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= limit) {\n            break;\n          }\n        }\n        if (separator.lastIndex === match.index) {\n          separator.lastIndex++; // Avoid an infinite loop\n        }\n      }\n      if (lastLastIndex === str.length) {\n        if (lastLength || !separator.test('')) {\n          output.push('');\n        }\n      } else {\n        output.push(str.slice(lastLastIndex));\n      }\n      return output.length > limit ? output.slice(0, limit) : output;\n    };\n\n    // For convenience\n    String.prototype.split = function(separator, limit) {\n      return self(this, separator, limit);\n    };\n\n    return self;\n  })();\n```\n\n</details>\n\n### 참고자료\n\n1. 정규식 테스트 사이트\n\n   [Non breaking space - Regex Tester/Debugger](https://www.regextester.com/105851)\n\n2. MS 공식 사이트\n\n   [Regular Expression Syntax (Scripting)](<https://docs.microsoft.com/en-us/previous-versions//1400241x(v=vs.85)?redirectedfrom=MSDN>)\n\n3. split 함수 재정의코드\n\n   [JavaScript split Bugs: Fixed!](http://blog.stevenlevithan.com/archives/cross-browser-split)\n","excerpt":"split()함수에 Regex를 사용 시 \"\"값이 return되지 않는 문제 고객이 네트워크 속도 문제로 인해 필요없는 파일을 load하지 않기로 하였다. 이에 대해서 특정 js파일을 load제외하였는데 그로인해 IE8에서 textsize…","fields":{"slug":"/IE8-Split-Bug/"},"frontmatter":{"date":"Mar 03, 2020","title":"IE8 Split Bug","tags":["IE","Split","Browser Bug"]}}}]}},"pageContext":{}}}