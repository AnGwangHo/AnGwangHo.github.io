{"componentChunkName":"component---src-pages-search-tsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"rawMarkdownBody":"\r\n## <center>Electronics Shop</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### Input Format\r\n\r\n| 변수      | 값                |\r\n| --------- | ----------------- |\r\n| keyboards | [가격, 가격, ...] |\r\n| drives    | [가격, 가격, ...] |\r\n| b         | 예산숫자          |\r\n\r\n### 제한사항\r\n\r\n> - `keyboards`, `drives` 각 배열 중 1개 씩 선택하여 총 2개를 구입\r\n> - `keyboards`, `drives` 중 가장 비싼 가격의 값을 조합하여 `b`를 초과하지 않는 범위의 값을 반환\r\n> - `b`의 예산을 초과하여 키보드+드라이브를 구입하지 못함\r\n\r\n### 입출력 예\r\n\r\n> | keyboards | drives  | b   | return |\r\n> | --------- | ------- | --- | ------ |\r\n> | [3,1]     | [5,2,8] | 10  | 9      |\r\n> | [4]       | [5]     | 5   | -1     |\r\n\r\n### 코드\r\n\r\n1.\r\n\r\n```javascript\r\nfunction getMoneySpent(keyboards, drives, b) {\r\n  let sum_array = keyboards.map(keyboard => {\r\n    const max = Math.max(\r\n      ...drives.map(drive => {\r\n        return keyboard + drive > b ? -1 : keyboard + drive;\r\n      })\r\n    );\r\n    return max;\r\n  });\r\n  return Math.max(...sum_array);\r\n}\r\n```\r\n\r\n출처: hackerrank Algorithms, https://www.hackerrank.com/challenges/drawing-book/leaderboard\r\n","excerpt":"Electronics Shop javascript Input Format 변수 값 keyboards 가격, 가격, ... drives 가격, 가격, ... b 예산숫자 제한사항 ,  각 배열 중 1개 씩 선택하여 총…","fields":{"slug":"/algorithm-ElectronicsShop/"},"frontmatter":{"date":"Apr 24, 2020","title":"Electronics Shop(javascript)","tags":["알고리즘","HackerRank","Easy"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[해시] 위장</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.\r\n> - 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return\r\n\r\n### 제한사항\r\n\r\n> - clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.\r\n> - 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.\r\n> - 같은 이름을 가진 의상은 존재하지 않습니다.\r\n> - clothes의 모든 원소는 문자열로 이루어져 있습니다.\r\n> - 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '\\_' 로만 이루어져 있습니다.\r\n> - 스파이는 하루에 최소 한 개의 의상은 입습니다.\r\n\r\n### 입출력 예\r\n\r\n> | clothes                                                                        | return |\r\n> | ------------------------------------------------------------------------------ | ------ |\r\n> | [[yellow_hat, headgear], [blue_sunglasses, eyewear], [green_turban, headgear]] | 5      |\r\n> | [[crow_mask, face], [blue_sunglasses, face], [smoky_makeup, face]]             | 3      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(clothes) {\r\n  var type = [clothes[0][1]];\r\n  var value_array = [[clothes[0][0]]];\r\n  //1. 카테고리 분류\r\n  let len = clothes.length;\r\n  if (len === 1) return 1;\r\n\r\n  let item = '';\r\n  for (let i = 1; i < len; i++) {\r\n    item = clothes[i];\r\n    if (type.includes(item[1])) {\r\n      value_array[type.indexOf(item[1])].push(item[0]);\r\n    } else {\r\n      value_array[type.push(item[1]) - 1] = [item[0]];\r\n    }\r\n  }\r\n\r\n  //2. 갯수 추출 후 경우의 수 구하기\r\n  var sum = value_array.reduce((a, b) => {\r\n    return a * (b.length + 1);\r\n  }, 1);\r\n  return sum - 1;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"해시 위장 javascript 조건 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 제한사항 clothes…","fields":{"slug":"/algorithm-위장/"},"frontmatter":{"date":"Apr 23, 2020","title":"위장(javascript)","tags":["알고리즘","프로그래머스","해시"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>Time Conversion</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### Input Format\r\n\r\n- 01 <= hh <= 12\r\n- 00 <= mm,ss <= 59\r\n\r\n| 변수 | 값                       |\r\n| ---- | ------------------------ |\r\n| s    | hh:mm:ssAM or hh:mm:ssPM |\r\n\r\n### 제한사항\r\n\r\n> - 24 hour 형태의 hh:mm:ss 포맷으로 값을 반환\r\n> - 00 <= hh <= 23\r\n\r\n### 입출력 예\r\n\r\n> | s          | return   |\r\n> | ---------- | -------- |\r\n> | 07:05:45PM | 19:05:45 |\r\n> | 12:05:45PM | 12:05:45 |\r\n> | 12:05:45AM | 00:05:45 |\r\n\r\n### 코드\r\n\r\n1. `:`를 구분자로 활용하여 문자열을 배열로 변환\r\n2. PM, AM을 구분하여 조건처리\r\n3. PM인 경우 24h인 경우 12h를 유지\r\n\r\n```javascript\r\nfunction timeConversion(s) {\r\n  const date_array = s.slice(0, s.length - 2).split(':');\r\n\r\n  if (s.slice(s.length - 2) == 'PM') {\r\n    date_array[0] != '12' && (date_array[0] = Number(date_array[0]) + 12);\r\n  } else {\r\n    date_array[0] == '12' && (date_array[0] = '00');\r\n  }\r\n  return date_array.join(':');\r\n}\r\n```\r\n\r\n출처: hackerrank Algorithms, https://www.hackerrank.com/challenges/drawing-book/leaderboard\r\n","excerpt":"Time Conversion javascript Input Format 01 <= hh <= 12 00 <= mm,ss <= 59 변수 값 s hh:mm:ssAM or hh:mm:ssPM 제한사항 24 hour 형태의 hh:mm:ss…","fields":{"slug":"/algorithm-TimeConversion/"},"frontmatter":{"date":"Apr 22, 2020","title":"Time Conversion(javascript)","tags":["알고리즘","HackerRank","Easy"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>Counting Valleys</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### Input Format\r\n\r\n| 변수 | 값                               |\r\n| ---- | -------------------------------- |\r\n| n    | 트래킹한 횟수                    |\r\n| p    | 위/아래 이동한 기록에대한 문자열 |\r\n\r\n### 제한사항\r\n\r\n> - `U`은 위로 이동, `D`는 아래로 이동\r\n> - 시작지점에서 다시 시작지점의 위치로 왔을 때 계곡 1개를 이동했다고 가정하여 카운팅\r\n> - 위로 이동 후 시작지점으로 내려오는 경우는 계곡으로 카운팅하지 않음\r\n\r\n### 입출력 예\r\n\r\n> | n   | s              | return |\r\n> | --- | -------------- | ------ |\r\n> | 8   | \"UDDDUDUU\"     | 1      |\r\n> | 12  | \"DDUUDDUDUUUD\" | 2      |\r\n\r\n### 코드\r\n\r\n1. 위로 갔다가 다시 시작지점 위치로 온 경우에 대한 예외처리\r\n2. `D`를 체크하여 시작지점 위치로 돌아온 경우 count 증가\r\n3. `D`, `U`를 비교하여 이동 추적필요\r\n\r\n```javascript\r\nfunction countingValleys(n, s) {\r\n  let stack = [];\r\n  let count = 0;\r\n\r\n  for (let char of s) {\r\n    if (!stack.length) stack.push(char);\r\n    else {\r\n      const last_value = stack[stack.length - 1];\r\n      if (last_value != char) stack.pop();\r\n      else stack.push(char);\r\n\r\n      if (!stack.length && last_value == 'D') count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n```\r\n\r\n출처: hackerrank Algorithms, https://www.hackerrank.com/challenges/drawing-book/leaderboard\r\n","excerpt":"Counting Valleys javascript Input Format 변수 값 n 트래킹한 횟수 p 위/아래 이동한 기록에대한 문자열 제한사항 은 위로 이동, 는 아래로 이동 시작지점에서 다시 시작지점의 위치로 왔을 때 계곡…","fields":{"slug":"/algorithm-CountingValleys/"},"frontmatter":{"date":"Apr 21, 2020","title":"Counting Valleys(javascript)","tags":["알고리즘","HackerRank","Easy"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[정렬] H-Index</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - H-Index<sup>[1](https://en.wikipedia.org/wiki/H-index)</sup>를 나타내는 값인 h를 구하고자 합니다.\r\n> - 어떤 과학자가 발표한 논문 `n`편 중, `h`번 이상 인용된 논문이 `h`편 이상이고 나머지 논문이 `h`번 이하 인용되었다면 `h`의 최댓값이 이 과학자의 H-Index\r\n> - 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하시오\r\n\r\n### 제한사항\r\n\r\n> - 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.\r\n> - 논문별 인용 횟수는 0회 이상 10,000회 이하입니다.\r\n\r\n### 입출력 예\r\n\r\n> | citations       | return |\r\n> | --------------- | ------ |\r\n> | [3, 0, 6, 1, 5] | 3      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(citations) {\r\n  const arr = citations.sort((a, b) => a - b);\r\n  let result = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    result.push(Math.min(arr[i], arr.length - i));\r\n  }\r\n  return Math.max(...result);\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"정렬 H-Index javascript 조건 H-Index1를 나타내는 값인 h를 구하고자 합니다. 어떤 과학자가 발표한 논문 편 중, 번 이상 인용된 논문이 편 이상이고 나머지 논문이 번 이하 인용되었다면 의 최댓값이 이 과학자의 H-Index…","fields":{"slug":"/algorithm-HIndex/"},"frontmatter":{"date":"Apr 20, 2020","title":"H-Index(javascript)","tags":["알고리즘","프로그래머스","정렬"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>Drawing Book</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### Input Format\r\n\r\n| 변수 | 값               |\r\n| ---- | ---------------- |\r\n| n    | 전체 페이지 개수 |\r\n| p    | 찾아야할 페이지  |\r\n\r\n### 제한사항\r\n\r\n> - Book의 경우 좌/우 총 2개의 page로 구성\r\n> - 1 Page는 항상 오른쪽 페이지에 존재\r\n> - `p` Page를 탐색 할 때 1 Page, 마지막 Page 총 2군대에서 탐색 가능하며 Page를 넘겨서 탐색\r\n> - 가장 최소의 비용으로 Page를 넘겨서 `p` Page를 탐색하여 반환\r\n\r\n### 입출력 예\r\n\r\n> | n   | p   | return |\r\n> | --- | --- | ------ |\r\n> | 6   | 2   | 1      |\r\n> | 5   | 4   | 0      |\r\n\r\n### 코드\r\n\r\n1. 전체 Page 수 `n`에 대하여 좌/우 page로 묶인 경우를 계산\r\n2. `p`Page가 1번 결과에서 어디에 위치하는지를 계산\r\n3. 첫 번째, 마지막 페이지 총 2곳에서 가장 최소의 비용으로 탐색한 결과를 반환\r\n\r\n```javascript\r\nfunction pageCount(n, p) {\r\n  const pages = Math.floor(n / 2) + 1;\r\n  const target_page = Math.floor(p / 2) + 1;\r\n  return Math.min(pages - target_page, target_page - 1);\r\n}\r\n```\r\n\r\n출처: hackerrank Algorithms, https://www.hackerrank.com/challenges/drawing-book/leaderboard\r\n","excerpt":"Drawing Book javascript Input Format 변수 값 n 전체 페이지 개수 p 찾아야할 페이지 제한사항 Book의 경우 좌/우 총 2개의 page로 구성 1 Page는 항상 오른쪽 페이지에 존재  Page를 탐색 할 때…","fields":{"slug":"/algorithm-DrawingBook/"},"frontmatter":{"date":"Apr 19, 2020","title":"Drawing Book(javascript)","tags":["알고리즘","HackerRank","Easy"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[스택/큐] 탑</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다.\r\n> - 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다.\r\n> - 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return\r\n\r\n### 제한사항\r\n\r\n> - heights는 길이 2 이상 100 이하인 정수 배열입니다.\r\n> - 모든 탑의 높이는 1 이상 100 이하입니다.\r\n> - 신호를 수신하는 탑이 없으면 0으로 표시합니다.\r\n\r\n### 입출력 예\r\n\r\n> | heights         | return          |\r\n> | --------------- | --------------- |\r\n> | [6,9,5,7,4]     | [0,0,2,2,4]     |\r\n> | [3,9,9,3,5,7,2] | [0,0,0,3,3,3,6] |\r\n> | [1,5,3,6,7,6,5] | [0,0,2,0,0,5,6] |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(heights) {\r\n  var answer = [0];\r\n  var max_index = 0;\r\n  var len = heights.length;\r\n\r\n  for (var i = 1; i < len; i++) {\r\n    if (max_index != i - 1 && heights[i - 1] > heights[i]) {\r\n      answer.push(i);\r\n      max_index = i - 1;\r\n    } else if (heights[max_index] > heights[i]) {\r\n      answer.push(max_index + 1);\r\n    } else {\r\n      answer.push(0);\r\n    }\r\n  }\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"스택/큐 탑 javascript…","fields":{"slug":"/algorithm-탑/"},"frontmatter":{"date":"Apr 18, 2020","title":"탑(javascript)","tags":["알고리즘","프로그래머스","스택/큐"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[동적계획법] 타일 장식물</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 타일의 개수 N이 주어질 때, N개의 타일로 구성된 직사각형의 둘레를 return\r\n\r\n### 제한사항\r\n\r\n> - N은 1 이상 80 이하인 자연수이다.\r\n\r\n### 입출력 예\r\n\r\n> | N   | return |\r\n> | --- | ------ |\r\n> | 5   | 26     |\r\n> | 6   | 42     |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(N) {\r\n  let w = 1,\r\n    h = 1;\r\n  for (let i = 1; i < N; i++) {\r\n    h += w;\r\n    w = h - w;\r\n  }\r\n  return w * 2 + h * 2;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"동적계획법 타일 장식물 javascript 조건 타일의 개수 N이 주어질 때, N개의 타일로 구성된 직사각형의 둘레를 return 제한사항 N은 1 이상 80 이하인 자연수이다. 입출력 예 N return 5 26 6 4…","fields":{"slug":"/algorithm-타일장식물/"},"frontmatter":{"date":"Apr 17, 2020","title":"타일 장식물(javascript)","tags":["알고리즘","프로그래머스","동적계획법"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[해시] 배스트앨범</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 속한 노래가 많이 재생된 장르를 먼저 수록합니다.\r\n> - 장르 내에서 많이 재생된 노래를 먼저 수록합니다.\r\n> - 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.\r\n\r\n### 제한사항\r\n\r\n> - genres[i]는 고유번호가 i인 노래의 장르입니다.\r\n> - plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다.\r\n> - genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다.\r\n> - 장르 종류는 100개 미만입니다.\r\n> - 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다.\r\n> - 모든 장르는 재생된 횟수가 다릅니다.\r\n\r\n### 입출력 예\r\n\r\n> | genres                                | plays                      | return       |\r\n> | ------------------------------------- | -------------------------- | ------------ |\r\n> | [classic, pop, classic, classic, pop] | [500, 600, 150, 800, 2500] | [4, 1, 3, 0] |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(genres, plays) {\r\n  //조건 1. 장르 총 합 순으로 정렬(내림차순)\r\n  //조건 2. 장르 중 높은 플레이순 2개만 출력\r\n\r\n  //{총재생수, [{인덱스, 재생수}]}\r\n  //장르를 object의 프로퍼티로 저장, 그 프로퍼티에 {총 재생수, 인덱스 달기}\r\n  if (genres.length === 1) return [0];\r\n\r\n  let best_album = {};\r\n  genres.map((genre, index) => {\r\n    if (!best_album[genre]) {\r\n      best_album[genre] = { allplay: plays[index], plays: [{ index: index, play: plays[index] }] };\r\n    } else {\r\n      best_album[genre].allplay += plays[index];\r\n      best_album[genre].plays.push({ index: index, play: plays[index] });\r\n    }\r\n  });\r\n\r\n  let sort_array = Object.keys(best_album);\r\n  if (sort_array.length > 1) {\r\n    sort_array.sort((a, b) => {\r\n      return best_album[b].allplay - best_album[a].allplay;\r\n    });\r\n  }\r\n\r\n  let answer = [];\r\n  sort_array.map(value => {\r\n    const plays = best_album[value].plays;\r\n    if (plays.length > 1) {\r\n      plays.sort((a, b) => {\r\n        return b.play - a.play;\r\n      });\r\n      answer.push(plays[0].index);\r\n      answer.push(plays[1].index);\r\n    } else answer.push(plays[0].index);\r\n  });\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"해시 배스트앨범 javascript 조건 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 제한사항 genresi…","fields":{"slug":"/algorithm-베스트앨범/"},"frontmatter":{"date":"Apr 16, 2020","title":"베스트앨범(javascript)","tags":["알고리즘","프로그래머스","해시"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[깊이/너비 우선 탐색(DFS/BFS)] 타겟 넘버</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - n개의 음이 아닌 정수\r\n> - 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return\r\n\r\n### 제한사항\r\n\r\n> - 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.\r\n> - 각 숫자는 1 이상 50 이하인 자연수입니다.\r\n> - 타겟 넘버는 1 이상 1000 이하인 자연수입니다.\r\n\r\n### 입출력 예\r\n\r\n> | numbers         | target | return |\r\n> | --------------- | ------ | ------ |\r\n> | [1, 1, 1, 1, 1] | 3      | 5      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(numbers, target) {\r\n  var answer = 0;\r\n\r\n  function dfs(target, numbers, k) {\r\n    if (k == numbers.length) {\r\n      let sum = 0;\r\n      for (var i = 0; i < numbers.length; i++) {\r\n        sum += numbers[i];\r\n      }\r\n      if (sum == target) {\r\n        answer++;\r\n      }\r\n      return;\r\n    } else {\r\n      numbers[k] *= 1;\r\n      dfs(target, numbers, k + 1);\r\n\r\n      numbers[k] *= -1;\r\n      dfs(target, numbers, k + 1);\r\n    }\r\n  }\r\n  dfs(target, numbers, 0);\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"깊이/너비 우선 탐색(DFS/BFS) 타겟 넘버 javascript 조건 n개의 음이 아닌 정수 사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target…","fields":{"slug":"/algorithm-타겟넘버/"},"frontmatter":{"date":"Apr 15, 2020","title":"타겟 넘버(javascript)","tags":["알고리즘","프로그래머스","깊이/너비 우선 탐색(DFS/BFS)"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2017 팁스타운] 짝지어 제거하기</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 알파벳 소문자로 이루어진 문자열을 가지고 시작\r\n> - 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다.\r\n> - 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료\r\n> - 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴\r\n\r\n### 제한사항\r\n\r\n> - 문자열의 길이 : 1,000,000이하의 자연수\r\n> - 문자열은 모두 소문자로 이루어져 있습니다.\r\n\r\n### 입출력 예\r\n\r\n> | s      | result |\r\n> | ------ | ------ |\r\n> | baabaa | 1      |\r\n> | cdcd   | 0      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(s) {\r\n  let stack = [];\r\n  const len = s.length;\r\n  for (let i = 0; i < len; i++) {\r\n    if (stack.length == 0) stack.push(s.charAt(i));\r\n    else {\r\n      if (stack[stack.length - 1] === s.charAt(i)) stack.pop();\r\n      else stack.push(s.charAt(i));\r\n    }\r\n  }\r\n\r\n  return stack.length === 0 ? 1 : 0;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2017 팁스타운 짝지어 제거하기 javascript 조건 알파벳 소문자로 이루어진 문자열을 가지고 시작 문자열에서 같은 알파벳이…","fields":{"slug":"/algorithm-짝지어제거하기/"},"frontmatter":{"date":"Apr 14, 2020","title":"짝지어 제거하기(javascript)","tags":["알고리즘","프로그래머스","2017 팁스타운"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[탐욕법(Greedy)] 큰 수 만들기</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.\r\n> - number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return\r\n\r\n### 제한사항\r\n\r\n> - number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.\r\n> - k는 1 이상 number의 자릿수 미만인 자연수입니다.\r\n\r\n### 입출력 예\r\n\r\n> | number       | k   | return   |\r\n> | ------------ | --- | -------- |\r\n> | \"1924\"       | 2   | \"94\"     |\r\n> | \"1231234\"    | 3   | \"3234\"   |\r\n> | \"4177252841\" | 4   | \"775841\" |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(number, k) {\r\n  var b = [];\r\n  for (var i = 0; i < number.length; i++) {\r\n    var c = number[i];\r\n    while (k > 0 && b.length > 0 && b[b.length - 1] < c) {\r\n      b.pop();\r\n      k--;\r\n    }\r\n    b.push(c);\r\n  }\r\n\r\n  b.splice(b.length - k, k);\r\n\r\n  return b.join('');\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"탐욕법(Greedy) 큰 수 만들기 javascript 조건 어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다. number에서 k…","fields":{"slug":"/algorithm-큰수만들기/"},"frontmatter":{"date":"Apr 13, 2020","title":"큰 수 만들기(javascript)","tags":["알고리즘","프로그래머스","탐욕법(Greedy)"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[스택/큐] 쇠막대기</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다.\r\n> - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다.\r\n> - 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다.\r\n> - 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.\r\n\r\n### 제한사항\r\n\r\n> - arrangement의 길이는 최대 100,000입니다.\r\n> - arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다.\r\n\r\n### 입출력 예\r\n\r\n> | arrangement               | skill_trees |\r\n> | ------------------------- | ----------- |\r\n> | \"()(((()())(())()))(())\" | 17          |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(arrangement) {\r\n  const bar_array = Array.from(arrangement);\r\n  let answer = 0,\r\n    stack = [];\r\n\r\n  bar_array.map((value, index, array) => {\r\n    if (value === '(') {\r\n      stack.push(value);\r\n    } else {\r\n      const prevalue = array[index - 1];\r\n      stack.pop();\r\n      if (prevalue == '(') {\r\n        answer += stack.length;\r\n      } else {\r\n        answer += 1;\r\n      }\r\n    }\r\n  });\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"스택/큐 쇠막대기 javascript…","fields":{"slug":"/algorithm-쇠막대기/"},"frontmatter":{"date":"Apr 12, 2020","title":"쇠막대기(javascript)","tags":["알고리즘","프로그래머스","스택/큐"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[Summer/Winter Coding(~2018)] 스킬트리</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 선행 스킬 순서가 `스파크 → 라이트닝 볼트 → 썬더`일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.\r\n> - 위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 `스파크 → 힐링 → 라이트닝 볼트 → 썬더`와 같은 스킬트리는 가능하지만, `썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더`와 같은 스킬트리는 불가능합니다.\r\n> - 선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.\r\n\r\n### 제한사항\r\n\r\n> - 스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.\r\n> - 스킬 순서와 스킬트리는 문자열로 표기합니다.\r\n>   - 예를 들어, C → B → D 라면 CBD로 표기합니다\r\n> - 선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.\r\n> - skill_trees는 길이 1 이상 20 이하인 배열입니다.\r\n> - skill_trees의 원소는 스킬을 나타내는 문자열입니다.\r\n>   - skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.\r\n\r\n### 입출력 예\r\n\r\n> | skill | skill_trees                       | return |\r\n> | ----- | --------------------------------- | ------ |\r\n> | \"CBD\" | [\"BACDE\", \"CBADF\", \"AECB\", \"BDA\"] | 2      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(skill, skill_trees) {\r\n  const tress_len = skill_trees.length;\r\n  const pattern = new RegExp('[^' + skill + ']', 'g');\r\n  let answer = 0;\r\n\r\n  for (let i = 0; i < tress_len; i++) {\r\n    const skill_check = skill_trees[i].replace(pattern, '');\r\n    const len = skill_check.length;\r\n\r\n    if (skill_check.substring(0, len) == skill.substring(0, len)) {\r\n      answer++;\r\n    }\r\n  }\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"Summer/Winter Coding(~2018) 스킬트리 javascript…","fields":{"slug":"/algorithm-skiltree/"},"frontmatter":{"date":"Apr 11, 2020","title":"스킬트리(javascript)","tags":["알고리즘","프로그래머스","Summer/Winter Coding(~2018)"]}}},{"node":{"rawMarkdownBody":"\r\n## IE브라우저에서 동기처리 중 script 실행 시 수행 안되는 특성\r\n\r\n### 분석\r\n\r\n- 현재, IE 브라우저에서 일정시간 script code가 수행 중 event를 발생 시 해당 event가 미발생\r\n- chrome, FF, Edge, Opera 브라우저에서 현상 미발생\r\n\r\n### 현상\r\n\r\n- 현상의 경우 `sleep`버튼을 클릭 후 `alert`버튼을 클릭 시 재현되며 하단의 iframe 또는 샘플링크에서 확인 가능합니다\r\n\r\n  ([**샘플**](https://github.com/AnGwangHo/sampleFile/tree/master/browser/IE스크립트block.html))\r\n\r\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/browser/IE스크립트block.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\r\n\r\n- 현재 `sleep`버튼 click event에서 3초동안 while문을 수행하도록 되어있습니다.\r\n\r\n- `alert`버튼의 경우 click event까지 각 event에 대하여 bind되어 console창에서 확인 가능하며 click event에서 alert을 발생합니다.\r\n\r\n- while문 수행시간이 약 3초이전의 경우 alert이 발생, 3초 이후의 경우 alert 미발생\r\n\r\n- 현재, IE브라우저의 경우 약 3초가량 script를 수행하는 동작이 존재 시 body에서 blur event가 발생하며 수행 중 발생되었던 event가 수행되지 않습니다.\r\n\r\n### 해결방안\r\n\r\n1. 비동기처리\r\n\r\n    - 현재, 샘플과 같이 while, for문 같은 반복문이 3초이상 수행되는 경우 비동기 처리를 통해 이를 회피할 수 있습니다.\r\n\r\n2. 반복문 3초미만 수행\r\n\r\n    - 반복문이 3초이상 수행되지 않도록 로직적으로 점검을 해볼 필요가 있습니다.\r\n","excerpt":"IE브라우저에서 동기처리 중 script 실행 시 수행 안되는 특성 분석 현재, IE 브라우저에서 일정시간 script code가 수행 중 event를 발생 시 해당 event가 미발생 chrome, FF, Edge, Opera…","fields":{"slug":"/IE스크립트block처리/"},"frontmatter":{"date":"Apr 10, 2020","title":"IE브라우저에서 동기처리 중 script 실행 시 수행 안되는 특성","tags":["IE","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\r\n## 조합문자 입력 중 input event에서 focus 이동 후 입력 시 이전 조합문자가 같이 입력되는 문제\r\n\r\n### 분석\r\n\r\n- 현재 브라우저 버그의 경우 input element event 작업 간 확인되었습니다.\r\n- input event에서 조합문자 입력 중 focus()로 다른 element를 이동 시 compositionend event가 발생\r\n- window7에서 현상 미발생\r\n- chrome 75~최신버전 확인한 결과 현상발생\r\n- 일본어, 한국 입력 시 이전 조합문자가 같이 입력되는 현상 확인\r\n\r\n### 현상\r\n\r\n- 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\r\n  ([**샘플**](https://github.com/AnGwangHo/sampleFile/tree/master/IME/조합중포커스이동.html))\r\n\r\n<iframe width=\"100%\" height=\"500\" src=\"https://angwangho.github.io/sampleFile/IME/조합중포커스이동.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\r\n\r\n- 일본어의 경우 해당 샘플의 input event에서 \"고\"를 체크하는 조건문을 value.length로 체크하도록 변경 시 확인 가능합니다.\r\n\r\n- 현재, focus() 이동 시 compositionend event가 발생하여 조합완료처리가 되었지만 이후 조합 가능한 문자(자음)를 입력 시 이전 조합문자에 이어져서 입력됩니다.\r\n\r\n### 해결방안\r\n\r\n1. callback처리\r\n\r\n    - 현재 focus 이동의 경우 바로 수행하는데 이 부분을 callback으로 처리 시 현상이 발생하지 않는 것을 확인하였습니다.\r\n\r\n2. keyup event에서 focus() 이동\r\n\r\n    - input event가 아닌 keyup event에서 focus 이동 시 현상 미발생 확인하였습니다.\r\n","excerpt":"조합문자 입력 중 input event에서 focus 이동 후 입력 시 이전 조합문자가 같이 입력되는 문제 분석 현재 브라우저 버그의 경우 input element event 작업 간 확인되었습니다. input event…","fields":{"slug":"/조합중포커스이동/"},"frontmatter":{"date":"Apr 09, 2020","title":"IME 조합 중 focus 이동 후 입력 시 이전 조합문자가 같이 입력되는 문제","tags":["IME","chrome","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\r\n## 마지막 문자가 개행문자인 경우 무시되는 현상\r\n\r\n### 현상\r\n\r\n- HTML Tag의 마지막 문자가 단독으로 존재하는 개행문자인 경우 개행처리를 하지 않음\r\n\r\n### 현상 확인 방법\r\n\r\n1. DOM에 value 직접 셋팅\r\n\r\n   <div>\r\n   <div style=\"background: yellow; border: 2px solid black; display: inline-block; color:black;\">\r\n   단독 개행문자(Enter)\r\n   </div>\r\n   <div style=\"background: yellow; border: 2px solid black; display: inline-block; color:black;\">\r\n   단독 개행문자(br Tag)</div>\r\n   </div>\r\n\r\n2. script를 사용하여 innerHTML의 value 변경\r\n    - \\n, \\r\\n, br tag를 마지막에 추가하여 value 변경\r\n\r\n### 해결 방안\r\n\r\n- 개행문자(\\n, br tag, etc...)를 하나 더 추가하여 개행처리가 되도록 한다.\r\n\r\n  <div style=\"background: yellow; border: 2px solid black; display: inline-block; color:black;\">\r\n  br Tag 2번 사용<br />\r\n  <br /></div>\r\n\r\n- textarea tag를 사용 한다.(단일 개행문자 적용가능)\r\n\r\n### 테스트 환경\r\n\r\n- IE11, Chrome, FF, Edge, Opera, Safari\r\n\r\n### 기타\r\n\r\n- innerHTML만이 아닌 textcontent로 개행문자를 적용 시 동일하게 현상 발생","excerpt":"마지막 문자가 개행문자인 경우 무시되는 현상 현상 HTML Tag의 마지막 문자가 단독으로 존재하는 개행문자인 경우 개행처리를 하지 않음 현상 확인 방법 DOM에 value 직접 셋팅 script를 사용하여 innerHTML의 value 변경 \\n…","fields":{"slug":"/newline/"},"frontmatter":{"date":"Apr 08, 2020","title":"마지막 문자가 개행문자인 경우 무시되는 현상","tags":["개행문자","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\n## Github action + Docker + GKE를 사용하여 클라우드 배포하기\n\n현재 진행하고 있는 동아리 활동에서 프로젝트 초기환경 구축을 하게 되었다. 이에 대하여 CI/CD를 구축하여 자동 테스트 및 배포를 수행하기로 결정하였다. 또한, 무중단 배포를 하기 위하여 Nginx를 서버로 loadbalancer를 설정하기로 하였다.\n\nAWS에 관련되어서는 자료가 많이 존재하는데 GCP관련해서는 내가 원하는 형태의 자료가 없어 삽질하는 과정이 많이 생겨 직접 남기고자 작성한다.\n\n### 사용 기술\n\n- Jest, Git Hook(husky), Github Action, Docker, Google Cloud Platform(Container Registry, Kubernetes Engine)\n\n### 배포 흐름도\n\n1. 개발자가 git push를 진행 → local에서 Git Hook이 감지하여 unit test 수행 후 결과에 따라 push 진행 및 fail처리\n2. develop 브랜치에 pull request 발생 시 Github Action을 통해 현재 코드에 대하여 unit test 진행 후 결과를 issue에 보여줌\n3. master 브랜치에 code merge된 경우 Github Action을 통해 Docker image 생성 후 Google Cloud Platfrom에 upload 및 Kubernetes에 배포\n\n## 실제로 CI/CD를 만들어보자!\n\n### React.js 프로젝트 준비하기\n\n프로젝트의 경우 현재, 동아리에서 사용하기로한 React.js를 기준으로 초기 프로젝트를 구성하였다.\n\n```Shell\nnpx create-react-app '프로젝트이름' --template typescript\n```\n\n- 이렇게 생성된 프로젝트에서 `npm start`명령어를 실행하여 프로젝트 환경이 정상적으로 설정된것을 확인한다.\n\n### Jest 설정하기\n\nunit test시 사용할 라이브러리는 `Jest`라는 라이브러리를 사용하기로 하였으며, 해당 라이브러리의 경우 npx로 프로젝트 설치 시 자동적으로 설치된다.\n\n- `npm run test`를 실행한다면 아래와 같은 결과가 나타날 것이다.\n\n  ![Alternate text][firsttest]\n\n- 우리가 필요한 것은 위와같이 추가입력을 통해 테스트하는 것이 아닌 결과에대한 성공/실패가 필요하다.\n- 이에 대하여 `package.json`에 아래 설정을 추가하고 해당 명령어를 실행하면 아래 결과와 같이 성공/실패에 대한 결과만을 보여준다!\n\n  ```JSON\n  //package.json\n  \"scripts\": {\n    ...,\n    \"test:watch\": \"react-scripts test --watchAll=false\",\n  }\n  ```\n\n  ![Alternate text][resulttest]\n\n자! 이것으로 CI/CD 배포를 위한 프로젝트 기본적인 준비가 끝났다. 다음으로는 CI/CD에 대한 설정을 진행하겠다.\n\n### Git Hook 설정하기\n\n작업자가 코드를 git에 push하기전에 unit test를 local에서 진행하고자 하였고 이에 대하여 Git hook이 지원하는 것을 검색 결과 알 수 있었다.\n\n그런데 기존 Git hook의 경우 shell 명령어로 작성해야하는 부분이 존재하였고 이에 관련하여 학습하고 진행하기에는 시간이 없어 대체제를 찾는 도중 `husky`라는 라이브러리가 있는것을 알게되었고 `package.json`에 설정만 입력하기만 하면되는 편리함이 존재하여 이를 선택하였다.\n\n- 아래 명령어를 입력하여 husky를 설치한다.\n\n  ```Shell\n  npm install husky --save-dev\n  ```\n\n- 설치 후 아래와 같이 hook을 사용할 부분과 명령어를 입력해주면 끝이다!🙌\n- 참고로, 위의 Jest에서 --watchAll=false을 설정하지 않으면 test 진행 시 `무한루프 효과`를 얻을 수 있다.(false를 지정하는 부분이 공식문서에 없어서 찾는데 힘들었다...)\n\n  ```JSON\n  //package.json\n  \"scripts\": {\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-push\": \"npm test:watch\"\n    }\n  }\n  ```\n\n### Github Action 설정하기\n\nCI의 경우 처음에는 기존의 jenkins, travis와 같은 유명한 도구들을 고려하였다. 관련되서 많은 레퍼런스나 예제들이 잘 되어있기에 금방 적용할 것 같았다.\n\n이러한 예제들을 보다가 Github Action이라는 CI를 보게되었는데 GitHub에서 지원해주며 추가적으로 플러그인이나 설정하는 부분이 없이 파일만 생성하면 자동적으로 해주는부분에서 GitHub Action을 선택하였다.\n\n- Github Action의 경우 저장소 탭중에 하나로 존재한다.\n\n  ![Alternate text][github-tab]\n\n- `Actions`을 클릭하면 아래와 같은 화면이 나타며 완성된 템플릿을 제공해 주고 있으며, 해당 템플릿을 사용하거나 새로 작성할 수 있다.\n\n  ![Alternate text][githubaction-template]\n\n- GitHub Actions의 경우 다른 포스트에서 다루기로하고 프로젝트 루트에서 `.github/workflows` 경로에 아래 파일을 생성해 준다.\n\n  ```YAML\n  #pr-test.yml\n  name: PR Test\n\n  on:\n    pull_request:\n      types: [opened, reopened]\n      branches: [ develop, feature, release ]\n\n  jobs:\n    Run Jest:\n      runs-on: [ubuntu-latest]\n      strategy:\n        matrix:\n          node-version: [12.x]\n      steps:\n      - name: npm install\n        run: npm install\n      - name: run test code\n        run: npm run test:watch\n\n      - name: if fail\n        uses: actions/github-script@0.8.0\n        with:\n          github-token: ${{ github.token }}\n          script: :|\n            const ref = \"${{github.ref}}\"\n            const pull_number = Number(ref.split(\"/\")[2])\n            await github.pulls.createReview({\n              ...context.repo,\n              pull_number,\n              body:\"테스트코드를 다시 확인해주세요. \",\n              event:\"REQUEST_CHANGES\"\n            })\n            await github.pulls.update({\n              ...context.repo,\n              pull_number,\n              state:\"closed\"\n            })\n        if: failure()\n  ```\n\n  ```YAML\n  #google.yml\n  name: Build and Deploy to GKE\n\n  on:\n    pull_request:\n      types: [closed]\n      branches:\n        - master\n\n  # Environment variables available to all jobs and steps in this workflow\n  env:\n    GKE_PROJECT: ${{ secrets.GKE_PROJECT }}\n    GKE_EMAIL: ${{ secrets.GKE_EMAIL }}\n    GITHUB_SHA: ${{ github.sha }}\n    GKE_ZONE: ${{ secrets.GKE_ZONE }}\n    GKE_CLUSTER: ${{ secrets.GKE_CLUSTER }}\n    IMAGE: ${{ secrets.IMAGE }}\n    REGISTRY_HOSTNAME: ${{ secrets.REGISTRY_HOSTNAME }}\n    DEPLOYMENT_NAME: ${{ secrets.DEPLOYMENT_NAME }}\n\n  jobs:\n    setup-build-publish-deploy:\n      name: Setup, Build, Publish, and Deploy\n      runs-on: ubuntu-latest\n      steps:\n\n      - name: Checkout\n        uses: actions/checkout@v2\n\n      # Setup gcloud CLI\n      - uses: GoogleCloudPlatform/github-actions/setup-gcloud@master\n        with:\n          version: '285.0.0'\n          project_id: ${{ secrets.GCP_PROJECT_ID }}\n          service_account_email: ${{ secrets.GKE_EMAIL }}\n          service_account_key: ${{ secrets.GKE_KEY }}\n\n      # Configure docker to use the gcloud command-line tool as a credential helper\n      - run: |\n          gcloud auth configure-docker\n\n      # Build the Docker image\n      - name: Build\n        run: |\n          docker build -t \"$REGISTRY_HOSTNAME\"/\"$GKE_PROJECT\"/\"$IMAGE\":\"$GITHUB_SHA\" \\\n            --build-arg GITHUB_SHA=\"$GITHUB_SHA\" \\\n            --build-arg GITHUB_REF=\"$GITHUB_REF\" .\n      # Push the Docker image to Google Container Registry\n      - name: Publish\n        run: |\n          docker push $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:$GITHUB_SHA\n\n      # Set up kustomize\n      - name: Set up Kustomize\n        run: |\n          curl -o kustomize --location https://github.com/kubernetes-sigs/kustomize/releases/download/v3.1.0/kustomize_3.1.0_linux_amd64\n          chmod u+x ./kustomize\n      # Deploy the Docker image to the GKE cluster\n      - name: Deploy\n        run: |\n          gcloud container clusters get-credentials $GKE_CLUSTER --zone $GKE_ZONE --project $GKE_PROJECT\n          ./kustomize edit set image $REGISTRY_HOSTNAME/$GKE_PROJECT/$IMAGE:${GITHUB_SHA}\n          ./kustomize build . | kubectl apply -f -\n          kubectl rollout status deployment/$DEPLOYMENT_NAME\n          kubectl get services -o wide\n  ```\n\n- `google.yml`의 경우 이후 GKE배포 단계에서 설명하기로 하며, `pr-test.yml`를 보면 develop, feature, release 브랜치에 pull request가 발생 시 issue가 'opened, reopened'시점에 수행되며 해당 코드에대하여 test 후 실패 시 issue에 리뷰를 달게한다.\n\n- 이제, 해당 파일을 git에 반영 시 브랜치에 pull request시 수행되며 결과를 Action탭에서 볼 수 있다.\n\n  ![Alternate text][githubaction-result]\n\n### 클라우드에 배포하기\n\n이제, 마지막단계로 프로젝트를 build후 Docker image를 만들어 클라우드에서 실행 할 것이다.\n\n1. Docker관련 설정파일 생성\n\n   - Docker의 경우 가상환경에서 실행 되므로 현재 local에 Docker를 설치할 필요는 없다.\n   - `.dockerignore`, `Dockerfile` 총 2개의 파일을 프로젝트 루트에서 생성한다.\n\n     ```Docker\n     #.dockerignore\n     .git\n     .hg\n     .svn\n     .dockerignore\n\n     node_modules\n     Dockerfile\n     npm-debug.log\n     ```\n\n     ```Docker\n     #Dockerfile\n     FROM node:12 as builder\n\n     WORKDIR /\n\n     COPY package.json ./\n     RUN npm install --silent\n     COPY . .\n     RUN npm run build\n\n     #Nginx에 build 결과물 upload\n     FROM nginx:1.17-alpine\n\n     COPY --from=builder /build /usr/share/nginx/html\n\n     EXPOSE 80\n     CMD [ \"nginx\", \"-g\", \"daemon off;\" ]\n     ```\n\n   - `.dockerignore`의 경우 .gitignore와 같이 Docker build시 제외할 항목에 대하여 기술한다.\n   - `Dockerfile`의 경우 node를 통해 build를 한 후 build된 결과물을 nginx에 복사한 후 Docker image를 만든다.\n\n2. GKE 배포\n\n   배포하기에 앞서 우선적으로 GCP에 계정이 존재해야 하므로 GCP에 가입한다.[(링크)](https://console.cloud.google.com/)\n\n   - 가입 후 아래와 같이 새 프로젝트를 하나 생성한다.\n\n     ![Alternate text][gke1]\n\n   - 우선적으로 해당 프로젝트에 접근권한을 설정하기 위하여 \"IAM 및 관리자\"-\"서비스 계정\"을 선택한다.\n\n     ![Alternate text][gke2]\n\n     ![Alternate text][gke3]\n\n   - 상단의 \"서비스 계정 만들기\"를 선택하여 단계별로 진행하며 2단계에서는 아래와 같은 권한을 설정한다.(저장소 관리자의 경우 Storage 탭에 있다)\n\n     ![Alternate text][gke4]\n\n   - 생성 완료시 아래와 같이 키가 생성되며 해당 키를 클릭하여 상제 정보에 들어간다.\n\n     ![Alternate text][gke5]\n\n   - \"수정\"을 선택 후 \"키 만들기\"를 선택하여 JSON형태로 만들기를 선택 시 json파일이 다운로드된다. 이 파일의 경우 이후 단계에서 필요함으로 잘 기억해두자\n\n     ![Alternate text][gke6]\n\n   - Docker의 경우 \"Container Registry\"에 보관될 것이므로 해당 탭을 선택 후 사용설정 버튼을 클릭한다.\n\n   - \"Kubernetes Engine\"탭을 선택하여 \"클러스터\"를 선택 후 \"클러스터 만들기\"를 진행한다.\n\n   - 클러스터의 생성 시 아래와 같이 진행하며 이름의 경우 자유롭게 설정한다. 영역의 경우 `asia-northeast3-c`를 설정한다.(서울)\n\n     ![Alternate text][gke7]\n\n   - 생성 완료 시 아래와 같이 이전 탭에 생성된 것을 볼 수 있다.\n\n     ![Alternate text][gke8]\n\n   이것으로 자동배포를 위한 기본적인 GCP 설정을 완료하였다. 마지막으로 GitHub 저장소에 Action 수행 시 사용할 key값들을 설정해 주면 된다.\n\n3. GitHub Secrets 값 설정\n\n   해당 항목의 경우 Github 저장소의 `Settings-Secrets`에 존재하며 'Add a new secret'를 선택하여 입력 가능하다.\n\n   등록해야할 키의 종류는 아래와 같다.\n\n   | Key               | value                                                                                       |\n   | ----------------- | ------------------------------------------------------------------------------------------- |\n   | DEPLOYMENT_NAME   | 동적으로 생성할 deployment 이름으로 `GCP-Kubernetes Engine-작업부하`에 생성된다.            |\n   | GKE_CLUSTER       | 위에서 생성한 클러스터 이름을 입력한다.                                                     |\n   | GKE_EMAIL         | 서비스 계정에서 생성된 email포함 풀 텍스트를 입력한다.                                      |\n   | GKE_KEY           | 서비스 계정 만들기에서 다운로드한 json파일 내용을 전부 복사 후 붙여넣기                     |\n   | GKE_PROJECT       | GCP에 생성한 프로젝트 이름을 입력한다.                                                      |\n   | GKE_ZONE          | 클러스터에서 생성한 영역의 이름을 입력한다.                                                 |\n   | IMAGE             | Docker image 이름으로 자유롭게 입력한다.                                                    |\n   | REGISTRY_HOSTNAME | gcr.io, us.gcr.io, eu.gcr.io, [asia.gcr.io](http://asia.gcr.io) 중 1개를 선택하여 입력한다. |\n\n   - 이렇게 등록된 키들이 이전에 생성한 `google.yml`에서 `${{ secrets.GKE_PROJECT }}`형태로 사용되게 된다.\n\n4. kustomization 설정파일 생성하기\n\n   이 부분에대해서 찾느라 많은 시간을 소요했던 것 같다. GKE의 경우 Github Action에 템플릿이 존재하는데 해당 템플릿을 실행 시 kustomization.yaml파일이 존재해야 한다.\n\n   - 아래 파일들을 프로젝트에 다음과 같이 생성한다.\n\n     ```YAML\n     #kustomization.yaml\n     resources:\n         - ./k8s/deployment.yaml\n         - ./k8s/service.yaml\n     ```\n\n     ```YAML\n     #./k8s/deployment.yaml\n     apiVersion: apps/v1\n     kind: Deployment\n     metadata:\n       name: react-nginx-deployment #deployment 이름으로 위의 Secrets에 입력한 값과 동일하게 맞춘다.\n     spec:\n       replicas: 3\n       selector:\n         matchLabels:\n             app: react-test #자유롭게 설정\n       template:\n         metadata:\n           labels:\n             app: react-test #자유롭게 설정\n         spec:\n           containers:\n             - name: react-test #자유롭게 설정\n               image: gcr.io/yapp16-findzone/react-test:latest #image 위치로 추후 동적으로 변경하나 프로젝트-이미지 이름으로 미리 설정해준다.\n               ports:\n                 - containerPort: 80\n     ```\n\n     ```YAML\n     #./k8s/service.yaml\n     apiVersion: v1\n     kind: Service\n     metadata:\n       name: react-test #Kubernetes Engine-서비스 및 수신에 생성될 이름이다.\n       labels:\n         app: react-test #자유롭게 설정\n     spec:\n       ports:\n         - name: \"80\"\n           port: 80\n           targetPort: 80\n       selector:\n         app: react-test #deployment에서 containers.name과 동일하게 설정한다.\n       type: LoadBalancer\n     ```\n\n5. 브랜치 merge하기\n\n   이제 모든 설정은 완료되었다. master 브랜치에 pull request가 완료 시 GKE를 만들고 배포가 될 것이다.\n\n   - 만약, master 브랜치에 pull request가 완료 되고 성공적으로 GitHub Action이 수행 될 시 아래와 같이 설정한 이름으로 deployment, service가 생성되고 `서비스 및 인그레스`의 엔드포인트를 통해서 접근할 수 있다!✌\n\n     ![Alternate text][gke9]\n\n     ![Alternate text][gke10]\n\n참고\n\n- [Git Hook(husky) 라이브러리](https://www.npmjs.com/package/husky)\n\n- [Google 컨테이너식 웹 애플리케이션 배포](https://cloud.google.com/kubernetes-engine/docs/tutorials/hello-app?hl=ko)\n\n- [Kustomize를 이용한 쿠버네티스 오브젝트의 선언형 관리](https://kubernetes.io/ko/docs/tasks/manage-kubernetes-objects/kustomization/)\n\n[firsttest]: test1.png '초기테스트'\n[resulttest]: test2.png '테스트결과'\n[github-tab]: githubaction1.png 'github 탭'\n[githubaction-template]: githubaction2.png 'github action 템플릿'\n[githubaction-result]: githubaction3.png 'github action결과'\n[gke1]: gke1.png '프로젝트생성'\n[gke2]: gke2.png '서비스계정'\n[gke3]: gke3.png '서비스계정만들기'\n[gke4]: gke4.png '권한설정'\n[gke5]: gke5.png '서비스계정생성결과'\n[gke6]: gke6.png '키만들기'\n[gke7]: gke7.png '클러스터설정'\n[gke8]: gke8.png '클러스터결과'\n[gke9]: gke9.png '동적생성결과1'\n[gke10]: gke10.png '동적생성결과2'\n","excerpt":"Github action + Docker + GKE를 사용하여 클라우드 배포하기 현재 진행하고 있는 동아리 활동에서 프로젝트 초기환경 구축을 하게 되었다. 이에 대하여 CI/CD…","fields":{"slug":"/React-CICD.md/"},"frontmatter":{"date":"Apr 07, 2020","title":"React.js CI/CD 구축하기","tags":["React.js","CI/CD"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[스택/큐] level2 프린터</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.\r\n> - 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.\r\n> - 그렇지 않으면 J를 인쇄합니다.\r\n\r\n### 제한사항\r\n\r\n> - 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.\r\n> - 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.\r\n> - location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.\r\n\r\n### 입출력 예\r\n\r\n> | priorities         | location | return |\r\n> | ------------------ | -------- | ------ |\r\n> | [2, 1, 3, 2]       | 2        | 1      |\r\n> | [1, 1, 9, 1, 1, 1] | 0        | 5      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(priorities, location) {\r\n  //중요도, 요청 문서 index\r\n  let target_index = location; //user가 선택한 index\r\n  let answer = 1;\r\n  let first = -1;\r\n\r\n  while (priorities.length > 0) {\r\n    //1. 가장 앞에 있는 문서를 추출\r\n    first = priorities.shift();\r\n    //2. 중요도 높은 문서가 존재 시 뒤로 넣음\r\n    if (priorities.some((value, index) => value > first)) {\r\n      priorities.push(first);\r\n    } else {\r\n      if (target_index === 0) {\r\n        break;\r\n      } else answer++;\r\n    }\r\n    /*3. 사용자가 선택한 문서가 중요도가 제일 높지 않은 경우\r\n             현재 대기목록의 맨 끝으로 index를 옮긴다.\r\n        */\r\n    if (target_index === 0) target_index = priorities.length - 1;\r\n    else target_index--;\r\n  }\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"스택/큐 level2 프린터 javascript 조건 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J…","fields":{"slug":"/algorithm-printer/"},"frontmatter":{"date":"Apr 06, 2020","title":"프린터(javascript)","tags":["알고리즘","프로그래머스","스택/큐"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[스택/큐] level2 기능개발</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 첫 번째 작업이 완료 되어야 배포가 이루어 짐.\r\n> - 그 이전에 완료된 작업의 경우 첫 번째 작업이 완료 될때까지 대기 후 같이 배포 됨.\r\n\r\n### 제한사항\r\n\r\n> - 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.\r\n> - 작업 진도는 100 미만의 자연수입니다.\r\n> - 작업 속도는 100 이하의 자연수입니다.\r\n> - 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.\r\n\r\n### 입출력 예\r\n\r\n> | progresses | speeds   | return |\r\n> | ---------- | -------- | ------ |\r\n> | [93,30,55] | [1,30,5] | [2,1]  |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(progresses, speeds) {\r\n  //현재 작업률-index가 작을 수록 우선순위 높음, 진행속도 배열\r\n  let answer = []; //정답을 담을 배열\r\n  let need_days = []; //작업을 완료하기 위한 day를 담는 배열\r\n\r\n  const len = progresses.length;\r\n  for (let i = 0; i < len; i++) {\r\n    //1. 작업을 완료하기 위한 날짜를 구하여 배열에 담는다.(소수점 올림하여 처리)\r\n    need_days.push(Math.ceil((100 - progresses[i]) / speeds[i]));\r\n  }\r\n\r\n  let count = 0; //배포 시의 기능 개수\r\n  let max = 0; //작업의 필요한 Day중 가장 큰 값을 담는 변수\r\n  need_days.forEach((value, index) => {\r\n    //배포 가능한 경우\r\n    if (value > max) {\r\n      max = value;\r\n      //index-0인 경우 배포하지 않음\r\n      if (index > 0) {\r\n        answer.push(count);\r\n        count = 0;\r\n      }\r\n    }\r\n    count++;\r\n  });\r\n  //마지막 배포 Day에 대한 기능 갯수를 넣어줌\r\n  //forEach에 할 시 index를 조건문으로 체크해야 하므로 현재 배열의 길이만큼 계속 체크하는 오버헤드 존재\r\n  answer.push(count);\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"스택/큐 level2 기능개발 javascript 조건 첫 번째 작업이 완료 되어야 배포가 이루어 짐. 그 이전에 완료된 작업의 경우 첫 번째 작업이 완료 될때까지 대기 후 같이 배포 됨. 제한사항 작업의 개수(progresses, speeds…","fields":{"slug":"/algorithm-functiondevelop/"},"frontmatter":{"date":"Apr 05, 2020","title":"기능개발(javascript)","tags":["알고리즘","프로그래머스","스택/큐"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[스택/큐] level2 다리를 지나는 트럭</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다.\r\n> - 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다.\r\n\r\n### 제한사항\r\n\r\n> - bridge_length는 1 이상 10,000 이하입니다.\r\n> - weight는 1 이상 10,000 이하입니다.\r\n> - truck_weights의 길이는 1 이상 10,000 이하입니다.\r\n> - 모든 트럭의 무게는 1 이상 weight 이하입니다.\r\n\r\n### 입출력 예\r\n\r\n> | 경과 시간 | 다리를 지난 트럭 | 다리를 건너는 트럭 | 대기 트럭 |\r\n> | --------- | ---------------- | ------------------ | --------- |\r\n> | 0         | []               | []                 | [7,4,5,6] |\r\n> | 1~2       | []               | [7]                | [4,5,6]   |\r\n> | 3         | [7]              | [4]                | [5,6]     |\r\n> | 4         | [7]              | [4,5]              | [6]       |\r\n> | 5         | [7,4]            | [5]                | [6]       | s |\r\n> | 6~7       | [7,4,5]          | [6]                | []        |\r\n> | 8         | [7,4,5,6]        | []                 | []        |\r\n\r\n### 코드\r\n\r\n```javascript\r\n/**\r\n *@param bridge_length 다리 길이\r\n *@param weight 다리가 버티는 무게(하중)\r\n *@param truck_weights 다리를 건널 트럭들의 배열(value:트럭무게)\r\n **/\r\nfunction solution(bridge_length, weight, truck_weights) {\r\n  let time = 0, //다리를 건너는 시간을 담는 변수\r\n    cross_trucks = [], //다리를 건너는 중인 트럭들의 배열({time,weight}, ...)\r\n    copy_trucks = truck_weights.concat(), //truck_weights의 copy하여 대기트럭 배열로 사용(다리 진입 시 배열에서 제거)\r\n    bridge_weight = 0; //현재 다리를 건너는 트럭 무게의 총 합(이 변수는 weight값보다 작거나 같아야한다)\r\n\r\n  //경과시간을 나타내는 loop(대기 중인 트럭이 있거나 다리를 건너는 트럭이 있는 동안 시간을 체크한다)\r\n  while (copy_trucks.length > 0 || cross_trucks.length > 0) {\r\n    time++;\r\n    const truck = copy_trucks[0]; //다리 진입 대기중인 하나의 트럭\r\n\r\n    //다리를 지난 트럭 Logic\r\n    if (cross_trucks[0] && cross_trucks[0].time + bridge_length === time) {\r\n      bridge_weight -= cross_trucks.shift().weight; //다리를 건너는 트럭배열에서 제거 및 현재 건너는 트럭들의 무게에서 뺀다.\r\n    }\r\n\r\n    //다리를 건너는 트럭 Logic(현재 다리에 진입할려는 트럭이 건너는 트럭들의 무게와 더했을 때 weight보다 낮은 경우 진입)\r\n    if (weight >= bridge_weight + truck) {\r\n      bridge_weight += truck;\r\n      cross_trucks.push({ time: time, weight: truck }); //다리를 건너는 트럭 배열에 추가\r\n      copy_trucks.shift(); //대기트럭 배열에서 제거\r\n    }\r\n  }\r\n\r\n  return time;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"스택/큐 level2 다리를 지나는 트럭 javascript 조건 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight…","fields":{"slug":"/algorithm-bridgetruck/"},"frontmatter":{"date":"Apr 04, 2020","title":"다리를 지나는 트럭(javascript)","tags":["알고리즘","프로그래머스","스택/큐"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[(2018년)KAKAO BLIND RECRUITMENT] 무지의 먹방 라이브</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 무지는 1번 음식부터 먹기 시작하며, 회전판은 번호가 증가하는 순서대로 음식을 무지 앞으로 가져다 놓는다.\r\n> - 마지막 번호의 음식을 섭취한 후에는 회전판에 의해 다시 1번 음식이 무지 앞으로 온다.\r\n> - 무지는 음식 하나를 1초 동안 섭취한 후 남은 음식은 그대로 두고, 다음 음식을 섭취한다.\r\n> - 다음 음식이란, 아직 남은 음식 중 다음으로 섭취해야 할 가장 가까운 번호의 음식을 말한다.\r\n> - 회전판이 다음 음식을 무지 앞으로 가져오는데 걸리는 시간은 없다고 가정한다.\r\n\r\n### 제한사항\r\n\r\n> - food_times 는 각 음식을 모두 먹는데 필요한 시간이 음식의 번호 순서대로 들어있는 배열이다.\r\n> - k 는 방송이 중단된 시간을 나타낸다.\r\n> - 만약 더 섭취해야 할 음식이 없다면 -1을 반환하면 된다.\r\n\r\n### 입출력 예\r\n\r\n> | food_times | k   | result |\r\n> | ---------- | --- | ------ |\r\n> | [3,1,2]    | 5   | 1      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(food_times, k) {\r\n  let sortFoodTimes = [];\r\n  const len = food_times.length;\r\n\r\n  //1. {index, time} 구조의 배열로 생성\r\n  //2. time 오름차순으로 정렬\r\n  sortFoodTimes = food_times\r\n    .map((time, index) => {\r\n      return { index: index + 1, time };\r\n    })\r\n    .sort((a, b) => {\r\n      return a.time - b.time;\r\n    });\r\n\r\n  //3. K를 넘어가는 순간을 찾아서 반환\r\n  for (let i = 0; i < len; i++) {\r\n    const food_time = sortFoodTimes[i].time; //index의 음식을 먹는데 필요한 시간\r\n    const remains_foods_len = len - i; //남은 음식의 갯수\r\n    const roop_time = (food_time - (i == 0 ? 0 : sortFoodTimes[i - 1].time)) * remains_foods_len; //현재 roop의 음식을 먹는데 걸리는 시간\r\n\r\n    if (k < roop_time) {\r\n      return sortFoodTimes.slice(i).sort((a, b) => a.index - b.index)[k % remains_foods_len].index;\r\n    }\r\n    k -= roop_time; //먹은 음식들의 시간을 제외\r\n  }\r\n\r\n  return -1;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"(2018년)KAKAO BLIND RECRUITMENT 무지의 먹방 라이브 javascript 조건 무지는…","fields":{"slug":"/algorithm-eatlive/"},"frontmatter":{"date":"Apr 03, 2020","title":"무지의 먹방 라이브(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[깊이/너비 우선 탐색(DFS/BFS)] level2 네트워크</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.\r\n\r\n### 제한사항\r\n\r\n> - 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.\r\n> - 각 컴퓨터는 0부터 n-1인 정수로 표현합니다.\r\n> - i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.\r\n> - computer[i][i]는 항상 1입니다.\r\n\r\n### 입출력 예\r\n\r\n> | n   | computers                         | return |\r\n> | --- | --------------------------------- | ------ |\r\n> | 3   | [[1, 1, 0], [1, 1, 0], [0, 0, 1]] | 2      |\r\n> | 3   | [[1, 1, 0], [1, 1, 1], [0, 1, 1]] | 1      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(n, computers) {\r\n  var answer = 0;\r\n\r\n  //DFS로 푸는 문제\r\n  const len = computers.length;\r\n  for (let i = 0; i < len; i++) {\r\n    //갯수만큼 loop\r\n    if (computers[i][i] != -1) {\r\n      //방문한 Node인지 체크\r\n      answer++; //현재 시작하는 Node가 Root Node가 됨\r\n      dfs(computers, i, n);\r\n    }\r\n  }\r\n\r\n  function dfs(computers, idx, n) {\r\n    for (let j = 0; j < n; j++) {\r\n      //다른 Node에 대하여 전부 탐색해야함\r\n      if (computers[idx][j] == 1 && computers[idx][j] != -1) {\r\n        computers[idx][j] = computers[j][idx] = -1; //탐색한 경우 -1로 설정\r\n        dfs(computers, j, n);\r\n      }\r\n    }\r\n  }\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"깊이/너비 우선 탐색(DFS/BFS) level2 네트워크 javascript 조건 컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution…","fields":{"slug":"/algorithm-network/"},"frontmatter":{"date":"Apr 02, 2020","title":"네트워크(javascript)","tags":["알고리즘","프로그래머스","깊이/너비 우선 탐색(DFS/BFS)"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[완전탐색] level2 숫자야구</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 숫자는 맞지만, 위치가 틀렸을 때는 볼\r\n> - 숫자와 위치가 모두 맞을 때는 스트라이크\r\n> - 숫자와 위치가 모두 틀렸을 때는 아웃\r\n\r\n### 제한사항\r\n\r\n> - 질문의 수는 1 이상 100 이하의 자연수입니다.\r\n> - baseball의 각 행은 [세 자리의 수, 스트라이크의 수, 볼의 수] 를 담고 있습니다.\r\n\r\n### 입출력 예\r\n\r\n> | baseball                                             | return |\r\n> | ---------------------------------------------------- | ------ |\r\n> | [[123, 1, 1], [356, 1, 0], [327, 2, 0], [489, 0, 1]] | 2      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(baseball) {\r\n  let answer = 0;\r\n  const len = baseball.length;\r\n\r\n  //123~987까지의 숫자 중 정답가능성이 있는 숫자를 찾는다.\r\n  for (let i = 123; i <= 987; i++) {\r\n    const number = i + '';\r\n    //중복되는 숫자, 십의자리/일의 자리에 0이 존재하는 경우는 건너뛴다.\r\n    if (\r\n      number.charAt(0) == number.charAt(1) ||\r\n      number.charAt(1) == number.charAt(2) ||\r\n      number.charAt(2) == number.charAt(0) ||\r\n      number.charAt(1) == '0' ||\r\n      number.charAt(2) == '0'\r\n    )\r\n      continue;\r\n\r\n    let bflag = true;\r\n    //사용자가 질문한 배열에 현재의 숫자를 대입하여 동일한 결과를 얻는지 체크한다.\r\n    for (let j = 0; j < len; j++) {\r\n      const callNumber = baseball[j][0] + '';\r\n      const strike = baseball[j][1];\r\n      const ball = baseball[j][2];\r\n\r\n      //strike 체크\r\n      let countStrike = 0;\r\n      for (let k = 0; k < 3; k++) {\r\n        if (number.charAt(k) === callNumber.charAt(k)) countStrike++;\r\n      }\r\n\r\n      if (countStrike !== strike) {\r\n        bflag = false;\r\n        break;\r\n      }\r\n      //ball 체크\r\n      let countBall = 0;\r\n      for (let k = 0; k < 3; k++) {\r\n        if (number.indexOf(callNumber.charAt(k)) !== -1) countBall++;\r\n      }\r\n\r\n      //strike가 체크 된 경우 ball을 판단할 때 체크되므로 제외시켜 주어야 한다.\r\n      if (countBall - countStrike !== ball) {\r\n        bflag = false;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (bflag) answer++;\r\n  }\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"완전탐색 level2 숫자야구 javascript 조건 숫자는 맞지만, 위치가 틀렸을 때는 볼 숫자와 위치가 모두 맞을 때는 스트라이크 숫자와 위치가 모두 틀렸을 때는 아웃 제한사항 질문의 수는 1 이상 100 이하의 자연수입니다. baseball…","fields":{"slug":"/algorithm-numberbaseball/"},"frontmatter":{"date":"Apr 01, 2020","title":"숫자 야구(javascript)","tags":["알고리즘","프로그래머스","완전탐색"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[완전탐색] level2 카펫</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 빨간색 격자는 카펫 중앙에 위치, 갈색은 카펫 테투리에 그려짐\r\n> - 빨간색 격자는 사각형의 형태로 중앙에 존재해야 함\r\n\r\n### 제한사항\r\n\r\n> - 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.\r\n> - 빨간색 격자의 수 red는 1 이상 2,000,000 이하인 자연수입니다.\r\n> - 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.\r\n\r\n### 입출력 예\r\n\r\n> | brown | red | return |\r\n> | ----- | --- | ------ |\r\n> | 10    | 2   | [4, 3] |\r\n> | 8     | 1   | [3, 3] |\r\n> | 24    | 24  | [8, 6] |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(brown, red) {\r\n  var answer = [];\r\n  let bflag = false; //정답 구한 경우 loop에서 나오기 위한 변수\r\n\r\n  //가로길이를 1부터 red길이까지 loop\r\n  for (let i = 1; i <= red; i++) {\r\n    //세로길이를 1~가로길이 까지 loop\r\n    for (let j = 1; j <= i; j++) {\r\n      const size = i * j; //red의 갯수를 계산\r\n      if (red === size) {\r\n        //red와 같은 경우\r\n        if (brown === (i + 2) * 2 + j * 2) {\r\n          //brown의 갯수와 같은지 판단\r\n          answer = [i + 2, j + 2]; //brown의 경우 red를 감싸는 형태로 존재해야 함\r\n          bflag = true; //가로길이 loop를 break\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (bflag) break;\r\n  }\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"완전탐색 level2 카펫 javascript 조건 빨간색 격자는 카펫 중앙에 위치, 갈색은 카펫 테투리에 그려짐 빨간색 격자는 사각형의 형태로 중앙에 존재해야 함 제한사항 갈색 격자의 수 brown은 8 이상 5,00…","fields":{"slug":"/algorithm-carpet/"},"frontmatter":{"date":"Mar 31, 2020","title":"카펫(javascript)","tags":["알고리즘","프로그래머스","완전탐색"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[탐욕법] level2 구명보트</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 구명보트에 최대 2명까지 탑승 가능\r\n> - 구명보트의 무게를 초과하여 탑승 불가능\r\n\r\n### 제한사항\r\n\r\n> - 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.\r\n> - 각 사람의 몸무게는 40kg 이상 240kg 이하입니다.\r\n> - 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.\r\n> - 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.\r\n\r\n### 입출력 예\r\n\r\n> | people           | limit | return |\r\n> | ---------------- | ----- | ------ |\r\n> | [70, 50, 80, 50] | 100   | 3      |\r\n> | [70, 80, 50]     | 100   | 3      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(people, limit) {\r\n  //limit와 같은 무게의 사람들의 경우 1명만 탑승 가능하므로 제외\r\n  let array = people.filter(value => value < limit);\r\n  let answer = people.length - array.length;\r\n\r\n  array.sort((a, b) => b - a); //내림차순으로 정렬\r\n  while (array.length > 0) {\r\n    //배열이 존재하는 동안 loop\r\n    const number = array.pop(); //가장 낮은 몸무게를 배열에서 제외\r\n    const idx = array.findIndex(value => value + number <= limit); //같이 탑승 가능한 최대무게의 승객의 index를 탐색\r\n\r\n    if (idx !== -1) {\r\n      //동승 가능한 최대 몸무게의 사람이 있는 경우\r\n      array.splice(0, idx + 1); //동승 가능한 사람의 위치까지 배열에서 제외(앞의 사람들은 혼자만 탑승 가능)\r\n      answer += idx + 1; //동승 가능한 사람 + 혼자만 탑승 가능한 사람들\r\n    } //동승 가능한 사람이 없는 경우\r\n    else {\r\n      answer += len + 1; //전부 혼자 탑승하므로 loop 종료\r\n      break;\r\n    }\r\n  }\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"탐욕법 level2 구명보트 javascript 조건 구명보트에 최대 2명까지 탑승 가능 구명보트의 무게를 초과하여 탑승 불가능 제한사항 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다. 각 사람의 몸무게는 40kg 이상 240kg…","fields":{"slug":"/algorithm-saveboat/"},"frontmatter":{"date":"Mar 30, 2020","title":"구명보트(javascript)","tags":["알고리즘","프로그래머스","탐욕법"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2018 서머코딩] level2 영어 끝말잇기</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.\r\n> - 마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.\r\n> - 앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.\r\n> - 이전에 등장했던 단어는 사용할 수 없습니다.\r\n> - 한 글자인 단어는 인정되지 않습니다.\r\n\r\n### 제한사항\r\n\r\n> - 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.\r\n> - words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.\r\n> - 단어의 길이는 2 이상 50 이하입니다.\r\n> - 모든 단어는 알파벳 소문자로만 이루어져 있습니다.\r\n> - 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.\r\n> - 정답은 [ 번호, 차례 ] 형태로 return 해주세요.\r\n> - 만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.\r\n\r\n### 입출력 예\r\n\r\n> | n   | words                                                                                                                                | result |\r\n> | --- | ------------------------------------------------------------------------------------------------------------------------------------ | ------ |\r\n> | 3   | [tank, kick, know, wheel, land, dream, mother, robot, tank]                                                                          | [3,3]  |\r\n> | 5   | [hello, observe, effect, take, either, recognize, encourage, ensure, establish, hang, gather, refer, reference, estimate, executive] | [0,0]  |\r\n> | 2   | [hello, one, even, never, now, world, draw]                                                                                          | [1,3]  |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(n, words) {\r\n  const len = words.length;\r\n  let stack = {}; //object에 property로 저장\r\n\r\n  //단어수(words) 만큼 loop\r\n  for (let i = 0; i < len; i++) {\r\n    const word = words[i];\r\n    if (!stack[word]) {\r\n      //단어가 없으면 property에 저장\r\n      //최초 저장이 아닌 경우 && 마지막 문자로 단어를 말하지 않은 경우\r\n      if (i > 0 && words[i - 1].charAt(words[i - 1].length - 1) !== word.charAt(0)) {\r\n        return [(i % n) + 1, Math.ceil((i + 1) / n)]; //몇 번째 사람인지, 몇 번째 차례인지\r\n      } else {\r\n        stack[word] = word; //property에 저장\r\n      }\r\n    } else {\r\n      return [(i % n) + 1, Math.ceil((i + 1) / n)];\r\n    }\r\n  }\r\n  //탈락자 없는 경우\r\n  return [0, 0];\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2018 서머코딩 level2 영어 끝말잇기 javascript 조건 1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다. 마지막 사람이 단어를 말한 다음에는 다시…","fields":{"slug":"/algorithm-word-chain-game/"},"frontmatter":{"date":"Mar 29, 2020","title":"영어 끝말잇기(javascript)","tags":["알고리즘","프로그래머스","2018 서머코딩"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[탐욕법] level2 예상 대진표</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다.\r\n> - 몇 번째 라운드에 만나는지 반환\r\n\r\n### 제한사항\r\n\r\n> - N : 2<sup>1</sup> 이상 2<sup>20</sup> 이하인 자연수 (2의 지수 승으로 주어지므로 부전승은 발생하지 않습니다.)\r\n> - A, B : N 이하인 자연수 (단, A ≠ B 입니다.)\r\n\r\n### 입출력 예\r\n\r\n> | N   | A   | B   | answer |\r\n> | --- | --- | --- | ------ |\r\n> | 8   | 4   | 7   | 3      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(n, a, b) {\r\n  let answer = 0;\r\n  while (a != b) {\r\n    answer++;\r\n    a = Math.ceil(a / 2);\r\n    b = Math.ceil(b / 2);\r\n  }\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"탐욕법 level2 예상 대진표 javascript 조건 단, A번 참가자와 B번 참가자는 서로 붙게 되기 전까지 항상 이긴다고 가정합니다. 몇 번째 라운드에 만나는지 반환 제한사항 N : 21 이상 220 이하인 자연수 (…","fields":{"slug":"/algorithm-expectation-table/"},"frontmatter":{"date":"Mar 28, 2020","title":"예상 대진표(javascript)","tags":["알고리즘","프로그래머스","탐욕법"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2019 KAKAO BLIND RECRUITMENT][1차] 오픈채팅방</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> 1. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.\r\n>     - \"[닉네임]님이 들어왔습니다.\"\r\n> 2. 채팅방에서 누군가 나가면 다음 메시지가 출력된다.\r\n>     - \"[닉네임]님이 나갔습니다.\"\r\n> 3. 채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.\r\n>     - 채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.\r\n>     - 채팅방에서 닉네임을 변경한다.\r\n> 4. 닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.\r\n\r\n### 제한사항\r\n\r\n> - record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다.\r\n> - 다음은 record에 담긴 문자열에 대한 설명이다.\r\n>   - 모든 유저는 [유저 아이디]로 구분한다.\r\n>   - [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - Enter [유저 아이디][닉네임] (ex. Enter uid1234 Muzi)\r\n>   - [유저 아이디] 사용자가 채팅방에서 퇴장 - Leave [유저 아이디] (ex. Leave uid1234)\r\n>   - [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - Change [유저 아이디][닉네임] (ex. Change uid1234 Muzi)\r\n>   - 첫 단어는 Enter, Leave, Change 중 하나이다.\r\n>   - 각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다.\r\n>   - 유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다.\r\n>   - 유저 아이디와 닉네임의 길이는 1 이상 10 이하이다.\r\n>   - 채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.\r\n\r\n### 입출력 예\r\n\r\n> | record                                                                                                    | result                                                                                                    |\r\n> | --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------- |\r\n> | [\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\"] | [\"Prodo님이 들어왔습니다.\", \"Ryan님이 들어왔습니다.\", \"Prodo님이 나갔습니다.\", \"Prodo님이 들어왔습니다.\"] |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(record) {\r\n  var answer = [];\r\n  const strBuffer = ['님이 들어왔습니다.', '님이 나갔습니다.'];\r\n  let users = {};\r\n\r\n  //1. 배열을 역순으로 정렬.\r\n  record.reverse();\r\n  //2. 유저 array에 등록 후 있으면 꺼내오기\r\n  record.forEach(value => {\r\n    const array = value.split(' ');\r\n    if (array.length > 2 && !users[array[1]]) {\r\n      users[array[1]] = array[2];\r\n    }\r\n  });\r\n  record.reverse();\r\n\r\n  record.forEach(value => {\r\n    const array = value.split(' ');\r\n    if (array[0] == 'Enter') {\r\n      answer.push(users[array[1]] + strBuffer[0]);\r\n    } else if (array[0] == 'Leave') {\r\n      answer.push(users[array[1]] + strBuffer[1]);\r\n    }\r\n  });\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2019 KAKAO BLIND RECRUITMENT 오픈채팅방 javascript…","fields":{"slug":"/algorithm-openchat/"},"frontmatter":{"date":"Mar 27, 2020","title":"오픈채팅방(javascript)","tags":["알고리즘","프로그래머스","2019 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## 개념\r\n\r\n호이스팅(hoisting)은 단어 뜻과 같이 Javascript 엔진에서 javascript file을 parsing 단계에서 변수, 함수선언문에 대하여 스코프 상단으로 끌어올리는 것을 말한다.\r\n\r\n- 실제 code가 변경되는 것이 아닌 엔진 내부에서 가상적으로 끌어올려 code 해석 및 실행 함\r\n\r\n## 예시\r\n\r\n아래 코드에서 a라는 변수를 선언하였는데 선언 이전에 a라는 변수를 호출하는 코드가 존재 시 ReferenceError가 아닌 undefined가 출력된다.\r\n\r\n```Javascript\r\n//사용자 script\r\nconsole.log(a); // undefined\r\nvar a = 10;\r\nconsole.log(a); // 10\r\n```\r\n\r\n```Javascript\r\n//javascript 엔진 parsing 시\r\nvar a; //호이스팅 O\r\nconsole.log(a); // undefined\r\na = 10;\r\nconsole.log(a); // 10\r\n```\r\n\r\n- Javascript 엔진에서 parsing하는 경우 위 코드와 같이 변수선언을 최상단에서 하며 값 할당의 경우 기존 자리에서 진행한다.\r\n\r\n### const, let\r\n\r\nES6에서 추가된 const, let의 경우 호이스팅이 되지 않는다. 아래와 같이 code가 있는 경우 해당 코드는 ReferenceError가 발생한다.\r\n\r\n```Javascript\r\n//사용자 script\r\nconsole.log(a); // ReferenceError: Cannot access 'a' before initialization\r\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\r\nconst a = 10;\r\nlet b = 20;\r\nconsole.log(a); // 10\r\nconsole.log(b); // 20\r\n```\r\n\r\n```Javascript\r\n//javascript 엔진 parsing 시\r\nconsole.log(a); // ReferenceError: Cannot access 'a' before initialization\r\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\r\nconst a = 10; //호이스팅 X\r\nlet b = 20; //호이스팅 X\r\nconsole.log(a); // 10\r\nconsole.log(b); // 20\r\n```\r\n\r\n### 함수\r\n\r\n함수의 경우 함수 선언문의 경우 호이스팅이 되지만 함수 표현식의 경우 호이스팅이 되지 않는다.\r\n\r\n```Javascript\r\n//사용자 script\r\necho(); // \"함수선언문\"\r\necho2(); // TypeError: echo2 is not a function\r\n\r\nfunction echo() // 함수 선언문\r\n{ \r\n  console.log(\"함수선언문\");\r\n}\r\nvar echo2 = function() //함수 표현식\r\n{\r\n  console.log(\"함수표현식\");\r\n}\r\n```\r\n\r\n```Javascript\r\n//javascript 엔진 parsing 시\r\nvar echo2; // 변수에 대한 호이스팅 O\r\nfunction echo() // 함수에 대한 호이스팅 O\r\n{ \r\n  console.log(\"함수선언문\");\r\n}\r\n\r\necho(); // \"함수선언문\"\r\necho2(); // TypeError: echo2 is not a function\r\n\r\necho2 = function() //여기서 함수를 할당한다.\r\n{\r\n  console.log(\"함수표현식\");\r\n}\r\n```\r\n\r\n내부 함수의 경우 외부 함수 내 스코프에서 최상단으로 호이스팅이 발생한다.\r\n\r\n- 내부 함수가 함수 선언문인 경우\r\n\r\n  ```Javascript\r\n  //사용자 script\r\n  function outerFn()\r\n  {\r\n    var inner = innerFn();\r\n    console.log(typeof inner); //function\r\n    console.log(inner); // \"inner 함수선언문\"\r\n    function innerFn()\r\n    {\r\n        return \"inner 함수선언문\";\r\n    }\r\n  }\r\n\r\n  outerFn();\r\n  ```\r\n\r\n  ```Javascript\r\n  //javascript 엔진 parsing 시\r\n  function outerFn()\r\n  {\r\n    var inner; //호이스팅 O\r\n  \r\n    function innerFn() //호이스팅 O\r\n    {\r\n      return \"inner 함수선언문\";\r\n    }\r\n  \r\n    inner = innerFn(); //할당\r\n    console.log(typeof inner); //function\r\n    console.log(inner); // \"inner 함수선언문\"\r\n  }\r\n  \r\n  outerFn();\r\n  ```\r\n\r\n- 내부함수가 함수 표현식인 경우\r\n\r\n  ```Javascript\r\n  //사용자 script\r\n  function outerFn()\r\n  {\r\n    console.log(inner); // undefined\r\n    var inner = innerFn(); //함수 호출\r\n\r\n    var innerFn = function()\r\n    {\r\n        return \"inner 함수표현식\";\r\n    }\r\n  }\r\n\r\n  outerFn();\r\n  ```\r\n\r\n  ```Javascript\r\n  //javascript 엔진 parsing 시\r\n  function outerFn()\r\n  {\r\n    var innerFn; // 호이스팅 O\r\n    var inner; // 호이스팅 O\r\n    console.log(inner); // TypeError: inner is not a function\r\n    var inner = innerFn(); //함수 호출\r\n\r\n    var innerFn = function()\r\n    {\r\n        return \"inner 함수표현식\";\r\n    }\r\n  }\r\n\r\n  outerFn();\r\n  ```\r\n\r\n- const, let으로 함수표현식을 사용 시 호이스팅이 발생되지 않으므로 사용자 script 코드와 동일하게 해석한다.\r\n\r\n## 규칙\r\n\r\n1. 변수, 함수가 동일한 이름인 경우\r\n    - 변수가 함수보다 상위로 호이스팅\r\n    - 변수에 값이 할당되는 경우 함수 선언문을 덮어쓴다.\r\n    - 변수에 값이 할당되지 않는 경우 함수가 할당된다.\r\n\r\n    ```Javascript\r\n    //사용자 script\r\n    var a = 10;\r\n    var b;\r\n\r\n    function a()\r\n    {\r\n      console.log(\"함수a\");\r\n    }\r\n    function b()\r\n    {\r\n      console.log(\"함수a\");\r\n    }\r\n\r\n    console.log(typeof a); // number\r\n    console.log(typeof b); // function\r\n    ```\r\n\r\n    ```Javascript\r\n    //javascript 엔진 parsing 시\r\n    /*변수가 함수보다 상위로 호이스팅*/\r\n    var a; // 호이스팅 O\r\n    var b; // 호이스팅 O\r\n\r\n    /*함수가 변수를 덮어씀*/\r\n    function a() // 호이스팅 O\r\n    {\r\n      console.log(\"함수a\");\r\n    }\r\n    function b() // 호이스팅 O\r\n    {\r\n      console.log(\"함수a\");\r\n    }\r\n\r\n    /*값 할당을 통해 함수를 덮어씀*/\r\n    a = 10; //a:function -> a:number\r\n\r\n    console.log(typeof a); // number\r\n    console.log(typeof b); // function\r\n    ```\r\n\r\n## 참고\r\n\r\n- [Blog 호이스팅 정리](https://gmlwjd9405.github.io/2019/04/22/javascript-hoisting.html)\r\n\r\n- [W3C JavaScript Hoisting](https://www.w3schools.com/js/js_hoisting.asp)","excerpt":"개념 호이스팅(hoisting)은 단어 뜻과 같이 Javascript 엔진에서 javascript file을 parsing 단계에서 변수, 함수선언문에 대하여 스코프 상단으로 끌어올리는 것을 말한다. 실제 code…","fields":{"slug":"/hoisting/"},"frontmatter":{"date":"Mar 26, 2020","title":"호이스팅(hoisting)","tags":["hoisting","Javascript"]}}},{"node":{"rawMarkdownBody":"\r\n## React.js에 husky를 사용하여 Git Hook 적용하기\r\n\r\n---\r\n\r\n기존의 git hook의 경우 shell 방식으로 사용하였다. 이러한 방식은 shell 관련된 코드를 작성해야하는데 이와 관련된 자료나 학습에 많은 시간이 소요된다. 이러한 부분을 도와주는 라이브러리를 검색하다가 husky라는 라이브러리를 찾았으며, package.json에 설정만 추가하면 쉽고 빠르게 git hook기능을 사용할 수 있다.\r\n\r\n### 설치\r\n\r\n- 현재 React.js+typescript 프로젝트가 npx cra를 사용하여 생성되어있으며, 이를 기준으로 진행한다.\r\n- 아래 명령어를 입력하여 현재 프로젝트에 husky 라이브러리를 개발용으로 추가한다.\r\n  \r\n  ```Shell\r\n  npm install husky --save-dev\r\n  ```\r\n\r\n### 설정\r\n\r\n현재, husky라이브러리가 설치 되었고 git hook기능을 사용하여 commit 수행 전 자동 test를 실행하고자 한다. 이러한 실행동작을 위해서는 package.json에 설정이 필요하며 아래 코드를 참조하여 추가하면 된다.\r\n\r\n```JSON\r\n\"scripts\": {\r\n  ...,\r\n  \"test\": \"react-scripts test\",\r\n  \"test:watch\": \"react-scripts test --watchAll=false\", //test관련 추가\r\n},\r\n...,\r\n\"husky\": {\r\n  \"hooks\": {\r\n    \"pre-commit\": \"npm run test:watch\", //commit 전에 해야할 동작을 정의한다.\r\n    // \"pre-push\":, \"명령어\" 추가적인 행동설정 가능\r\n  }\r\n}\r\n```\r\n\r\n- 위에서 test:watch의 경우 기존 test동작 시 테스트 이후 동작에 대해서 키 입력을 해야한다. 우리가 하고자 하는 것은 단순히 test 결과에 대하여 true/false동작만을 필요로한다.\r\n\r\n- 이를 위해서 test시 모든 test에 대해서 수행되도록 —watchAll option을 주었고 =fasle를 하여 단순히 true/false결과만 받도록 하였다.\r\n\r\n- husky에는 hooks에 대해서 해야할 동작을 정의하였고 commit전에 test를 수행하도록 하였다.\r\n\r\n### 결과 동작\r\n\r\n- 일부러 App.tsx에 test시 실패가 되도록 코드를 수정하였다.\r\n\r\n    ![Alternate text][commit]\r\n\r\n- 이러한 상태에서 commit시 다음과 같은 alert창이 발생되고 commit이 실패함을 알 수 있다.\r\n\r\n    ![Alternate text][fail]\r\n\r\n### 참고\r\n\r\n- [[React] husky 사용법](https://velog.io/@jch9537/React-husky-%EC%82%AC%EC%9A%A9%EB%B2%95-1kk4wj5og4)\r\n\r\n- [Jest test 결과만 나오도록 하는 방법](https://stackoverflow.com/questions/39724017/running-cra-jest-in-non-interactive-mode)\r\n\r\n[commit]: image1.png 'commit수행'\r\n[fail]: image2.png 'commit실패'\r\n","excerpt":"React.js에 husky를 사용하여 Git Hook 적용하기 기존의 git hook의 경우 shell 방식으로 사용하였다. 이러한 방식은 shell…","fields":{"slug":"/Git-Hook.md/"},"frontmatter":{"date":"Mar 25, 2020","title":"Git Hook 사용하기","tags":["Git","Git Hook"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[찾아라 프로그래밍 마에스터] 폰켓몬</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택\r\n> - 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return\r\n\r\n### 제한사항\r\n\r\n> - nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다.\r\n> - nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다.\r\n> - 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다.\r\n> - 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다.\r\n\r\n### 입출력 예\r\n\r\n> | nums          | result |\r\n> | ------------- | ------ |\r\n> | [3,1,2,3]     | 2      |\r\n> | [3,3,3,2,2,4] | 3      |\r\n> | [3,3,3,2,2,2] | 2      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(nums) {\r\n  let max = nums.length / 2; //골라야하는 갯수\r\n\r\n  //중복제거\r\n  let stack = [];\r\n  nums.concat().forEach(value => {\r\n    if (stack.indexOf(value) === -1) stack.push(value);\r\n  });\r\n\r\n  return stack.length >= max ? max : stack.length;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"찾아라 프로그래밍 마에스터 폰켓몬 javascript 조건 최대한 많은 종류의 폰켓몬을 포함해서 N/2마리를 선택 가장 많은 종류의 폰켓몬을 선택하는 방법을 찾아, 그때의 폰켓몬 종류 번호의 개수를 return 제한사항 nums…","fields":{"slug":"/algorithm-phonecatmon/"},"frontmatter":{"date":"Mar 24, 2020","title":"폰켓몬 (javascript)","tags":["알고리즘","프로그래머스","찾아라 프로그래밍 마에스터"]}}},{"node":{"rawMarkdownBody":"\r\n## UIWebView에서 화면 밖으로 드래그 시 touchend event 미발생\r\n\r\n### 현상\r\n\r\niOS 장비에서 터치 후 기기 밖으로 드래시 touchend event가 미발생하는 현상입니다.\r\n\r\n1. iOS App store에서 webview를 검색 후 \"WebView - WKWebView and UIWebView rendering\"을 다운로드하여 앱을 실행합니다.\r\n2. 상단 3개의 버튼 중 좌측 'UIWebView'를 선택 합니다\r\n3. 샘플 주소를 해당 앱 URL에 입력합니다\r\n  ([**샘플주소**](https://angwangho.github.io/sampleFile/webview/iOS_UIWebView_screenOut.html))\r\n4. 노란색 textarea를 제외한 영역에서 화면밖으로 드래그합니다.\r\n    > 💡화면 우측 Edge영역에서 터치하여 밖으로 드래그 시 현상 재현이 수월하게 됩니다.\r\n5. 4번 동작을 반복 시 touchstart event만 textarea에 보이는 것을 확인합니다.\r\n\r\n- Safari브라우저, WKWebView에서는 touchend event 발생\r\n\r\n- UIWebView에서 iOS 버전 별로 가로/세로모드에 따라 touchend event 미발생\r\n  >   - iOS 11.2.6 세로모드\r\n  >   - iOS 12.1.1 가로모드\r\n\r\n### 해결방안\r\n\r\n1. touchend event 발생 유/무 체크\r\n    - touchstart event에서 callback을 사용하여 touchend event 발생 유/무를 체크합니다.\r\n2. WKWebView 사용","excerpt":"UIWebView에서 화면 밖으로 드래그 시 touchend event 미발생 현상 iOS 장비에서 터치 후 기기 밖으로 드래시 touchend event가 미발생하는 현상입니다. iOS App store에서 webview를 검색 후 \"WebView…","fields":{"slug":"/touchend-Bug/"},"frontmatter":{"date":"Mar 23, 2020","title":"UIWebView에서 touchend event 미발생","tags":["UIWebView","UIWebView Bug"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2017 윈터코딩] 소수 만들기</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return\r\n\r\n### 제안사항\r\n\r\n> - nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다.\r\n> - nums의 각 원소는 1 이상 1,000 이하의 자연수이며, 중복된 숫자가 들어있지 않습니다.\r\n\r\n### 입출력 예\r\n\r\n> | nums    | result |\r\n> | --------- | ------ |\r\n> | [1,2,3,4] | 1      |\r\n> | [1,2,7,6,4] | 4      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(nums) {\r\n  let answer = 0;\r\n\r\n  //1. 3자리 숫자 만들기\r\n  const len = nums.length;\r\n  for (let i = 0; i < len; i++)\r\n  {\r\n    for (let j = i+1; j < len; j++)\r\n    {\r\n      for (let k = j+1; k < len; k++)\r\n      {\r\n        const number = nums[i]+nums[j]+nums[k];\r\n        if (isPrime(number))\r\n          answer++;\r\n      }\r\n    }\r\n  }\r\n\r\n  //2. 소수 판별(2~number까지 하나씩 비교)\r\n  function isPrime(number)\r\n  {\r\n    if (number < 2) return true;\r\n    for (let i = 2; i < number; i++)\r\n    {\r\n      if (number % i == 0) return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2017 윈터코딩 소수 만들기 javascript 조건 nums에 있는 숫자들 중 서로 다른 3개를 골라 더했을 때 소수가 되는 경우의 개수를 return 제안사항 nums에 들어있는 숫자의 개수는 3개 이상 50개 이하입니다. nums…","fields":{"slug":"/algorithm-create-primenumber/"},"frontmatter":{"date":"Mar 22, 2020","title":"소수 만들기(javascript)","tags":["알고리즘","프로그래머스","2018 윈터코딩"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2018 윈터코딩] 방문 길이</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 좌표평면의 경계를 넘어가는 명령어는 무시\r\n> - 처음 걸어본 길의 길이를 구하여 return\r\n\r\n### 제안사항\r\n\r\n> - dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L' 이외에 문자는 주어지지 않습니다.\r\n> - dirs의 길이는 500 이하의 자연수입니다.\r\n\r\n### 입출력 예\r\n\r\n> | dirs    | answer |\r\n> | --------- | ------ |\r\n> | \"ULURRDLLU\" | 7      |\r\n> | \"LULLLLLLU\" | 7      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(dirs) {\r\n  let answer = [];\r\n  let gps = [0,0];\r\n  dirs.split(\"\").forEach((value) => {\r\n    let ret = false;\r\n    const pre_gps = gps.concat();\r\n    if (value == \"U\" && gps[1] < 5)\r\n    {\r\n      gps[1] += 1;\r\n      ret = true;\r\n    }\r\n    else if (value == \"D\" && gps[1] > -5)\r\n    {\r\n      gps[1] -= 1;\r\n      ret = true;\r\n    }\r\n    else if (value == \"R\" && gps[0] < 5)\r\n    {\r\n      gps[0] += 1;\r\n      ret = true;\r\n    }\r\n    else if (value == \"L\" && gps[0] > -5)\r\n    {\r\n      gps[0] -= 1;\r\n      ret = true;\r\n    }\r\n    //길은 양뱡향이 아닌 단방향으로 취급(\"L,R\" => ret : 1)\r\n    const filter = answer.filter(item => {\r\n      return item[0] == pre_gps[0] && item[1] == pre_gps[1] && item[2] == gps[0] && item[3] == gps[1] || item[0] == gps[0] && item[1] == gps[1] && item[2] == pre_gps[0] && item[3] == pre_gps[1]\r\n    })\r\n    if (ret && filter.length == 0)\r\n      answer.push(pre_gps.concat(gps));\r\n    });\r\n\r\n  return answer.length;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2018 윈터코딩 방문 길이 javascript 조건 좌표평면의 경계를 넘어가는 명령어는 무시 처음 걸어본 길의 길이를 구하여 return 제안사항 dirs는 string형으로 주어지며, 'U', 'D', 'R', 'L…","fields":{"slug":"/algorithm-loadlength/"},"frontmatter":{"date":"Mar 21, 2020","title":"방문 길이(javascript)","tags":["알고리즘","프로그래머스","2018 윈터코딩"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2018 윈터코딩] 쿠키 구입</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때(오름차순 정렬)\r\n> - 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N)\r\n> - A[i] 를 i번 바구니에 들어있는 과자 수라고 했을 때, A[l]+..+A[m] = A[m+1]+..+A[r] 를 만족해야 합니다\r\n> - 한 명의 아들에게 줄 수 있는 가장 많은 과자 수를 return(조건에 맞지 않으면 0을 return)\r\n\r\n### 제안사항\r\n\r\n> - cookie의 길이는 1 이상 2,000 이하입니다.\r\n> - cookie의 각각의 원소는 1 이상 500 이하인 자연수입니다.\r\n\r\n### 입출력 예\r\n\r\n> | cookie    | result |\r\n> | --------- | ------ |\r\n> | [1,1,2,3] | 3      |\r\n> | [1,2,4,5] | 0      |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(cookie) {\r\n  var answer = 0;\r\n  if (cookie.length <= 2) {\r\n    if (cookie.length == 2 && cookie[0] == cookie[1]) {\r\n      answer = cookie[0];\r\n    }\r\n    return answer;\r\n  }\r\n\r\n  //이분탐색\r\n  const len = cookie.length - 1;\r\n  for (\r\n    let i = 0;\r\n    i < len;\r\n    i++ //경계선\r\n  ) {\r\n    let presum = cookie[i]; //첫째 총 과자갯수\r\n    let preidx = i; //첫째 마지막에 추가한 바구니 위치\r\n    let postsum = cookie[i + 1]; //둘째 총 과자갯수\r\n    let postidx = i + 1; //둘째 마지막에 추가한 바구니 위치\r\n\r\n    //경계선을 기준으로 idx가 0 || len에 도달할때 까지\r\n    while (true) {\r\n      if (presum === postsum)\r\n        //첫째 과자갯수===둘째 과자갯수인 경우\r\n        answer = Math.max(presum, answer); //Max값인 경우에만 변수할당\r\n\r\n      if (preidx > 0 && presum <= postsum) {\r\n        //둘째 과자갯수가 더 많은 경우, idx가 0이 될때까지 과자의 총합을 더한다.\r\n        preidx--; //첫째 바구니 하나 더 추가\r\n        presum += cookie[preidx]; //첫째 과자갯수 총합에 더하기\r\n      } else if (postidx < len && presum >= postsum) {\r\n        //첫째 과자갯수가 더 많은 경우, idx가 len이 될때까지 과자의 총합을 더한다.\r\n        postidx++; //둘째 바구니 하나 더 추가\r\n        postsum += cookie[postidx]; //둘째 과자갯수 총합에 더하기\r\n      } //첫째 || 둘째의 바구니 위치가 0 || len에 도달한 경우 loop break\r\n      else break;\r\n    }\r\n  }\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2018 윈터코딩 쿠키 구입 javascript 조건 각 바구니 안에 들은 과자 수가 차례로 들은 배열 cookie가 주어질 때(오름차순 정렬) 두 아들이 받을 과자 수는 같아야 합니다(1 <= l <= m, m+1 <= r <= N) Ai 를 i…","fields":{"slug":"/algorithm-buycookie/"},"frontmatter":{"date":"Mar 20, 2020","title":"쿠키 구입(javascript)","tags":["알고리즘","프로그래머스","2018 윈터코딩"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2020 KAKAO BLIND RECRUITMENT] 괄호 변환</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다.\r\n> - 문자열 p를 이루는 '(' 와 ')' 의 개수는 항상 같습니다.\r\n> - 만약 p가 이미 올바른 괄호 문자열이라면 그대로 return 하면 됩니다.\r\n\r\n### 조건사항\r\n\r\n> - '(' 의 개수와 ')' 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.\r\n> - '('와 ')'의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.\r\n> - 예를 들어, \"(()))(\"와 같은 문자열은 균형잡힌 괄호 문자열 이지만 올바른 괄호 문자열은 아닙니다.\r\n> - 반면에 \"(())()\"와 같은 문자열은 균형잡힌 괄호 문자열 이면서 동시에 올바른 괄호 문자열 입니다.\r\n>\r\n> 1. 입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.\r\n> 2. 문자열 w를 두 \"균형잡힌 괄호 문자열\" u, v로 분리합니다. 단, u는 \"균형잡힌 괄호 문자열\"로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.\r\n> 3. 문자열 u가 \"올바른 괄호 문자열\" 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.\r\n>    - 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.\r\n> 4. 문자열 u가 \"올바른 괄호 문자열\"이 아니라면 아래 과정을 수행합니다.\r\n>    - 빈 문자열에 첫 번째 문자로 '('를 붙입니다.\r\n>    - 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.\r\n>    - ')'를 다시 붙입니다.\r\n>    - u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.\r\n>    - 생성된 문자열을 반환합니다.\r\n\r\n### 입출력 예\r\n\r\n> | p          | result     |\r\n> | ---------- | ---------- |\r\n> | \"(()())()\" | \"(()())()\" |\r\n> | \")(\"       | \"()\"       |\r\n> | \"()))((()\" | \"()(())()\" |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(p) {\r\n  function solve(p)\r\n  {\r\n    if (p == \"\") //1. Logic 수행\r\n    return p;\r\n\r\n    let stack = []; //Stack을 사용하여 균형잡힌 괄호 문자열 분리\r\n    let u=\"\", v=\"\";\r\n    for (let i = 0; i < p.length; i++) //2. Logic 수행\r\n    {\r\n      const now_char = p.charAt(i); //현재 비교할 문자(자주 사용하는 Data의 경우 유지보수 측면을 위하여 변수로 담는다)\r\n      if (i == 0) //최초 수행 시 stack에 push한다\r\n        stack.push(now_char);\r\n      else\r\n      {\r\n        const pre_char = stack[stack.length - 1]; //stack에 마지막에 들어간 문자\r\n        //전제조건에서 '균형잡힌 괄호 문자열'인 경우까지만 나누면 되므로 '올바른 괄호 문자열'인지는 판단하지 않는다.\r\n        if (pre_char === now_char) //이전 문자와 현재 문자가 같은 경우 [\"(\" == \"(\"] or [\")\" == \")\"] stack에 push한다.\r\n          stack.push(now_char)\r\n        else //다른 경우는 [\"(\" != \")\"] or [\")\" != \"(\"]인 경우\r\n          stack.pop();\r\n\r\n        if (stack.length == 0) //괄호의 쌍이 맞게 나눈 경우(균형잡힌 괄호 문자열인 경우)\r\n        {\r\n          u = p.slice(0, i + 1);\r\n          v = p.slice(i + 1);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (u.charAt(0) === \"(\") //3. Logic 수행\r\n    {\r\n      return u + solve(v); //3-1. Logic 수행\r\n    }\r\n    else //4. Logic 수행\r\n    {\r\n      u = u.slice(1 , u.length - 1); //4-4. Logic에서 첫 번째, 마지막 문자 제거, 미리 문자열 자르기를하여 혹시 모를 예외방지\r\n      let temp = \"\"; //4-4. Logic에서 변환된 문자열을 담을 임시변수\r\n      //loop에서 i = 1, len = u.length - 1한 경우 예외발생 가능성 있음(문자열이 1인경우)\r\n      for (let i = 0; i < u.length; i++) //4-4. Logic에서 괄호 방향 뒤집는 loop\r\n      {\r\n        if (u.charAt(i) == \"(\")\r\n          temp += \")\";\r\n        else\r\n          temp += \"(\";\r\n      }\r\n      return \"(\" + solve(v) + \")\" + temp; //4-1. 4-2. 4-3. 4-4. 수행\r\n    }\r\n    return u + solve(v); //4-5. 수행\r\n  }\r\n\r\n  return solve(p);\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2020 KAKAO BLIND RECRUITMENT 괄호 변환 javascript 조건 p는 '(' 와 ')' 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p…","fields":{"slug":"/algorithm-bracketchange/"},"frontmatter":{"date":"Mar 19, 2020","title":"괄호 변환(javascript)","tags":["알고리즘","프로그래머스","2020 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## 함수 호출에 따른 this\r\n\r\nJavascript함수는 호출 될 때, 매개변수로 argument와 this를 암묵적으로 전달 받는다.\r\n\r\n- Javascript에서의 this는 호출 될 때 인자로 전달받는 구조이므로, 호출 방식에 따라 this에 바인딩할 객체가 동적으로 결정된다.\r\n- 스코프(Scope)에서는 함수를 선언할 때 결정되었지만, this는 함수는 호출할 때 결정된다.\r\n\r\n### 함수의 호출방식\r\n\r\n1. 함수 호출\r\n2. 메소드 호출\r\n3. 생성자 함수 호출\r\n4. apply, call, bind 호출\r\n\r\n### 함수 호출\r\n\r\n브라우저에서 전역객체는 window이다. 이러한 전역객체는 전역 스코프(Global Scope)를 갖는 전역변수를 프로퍼티로 소유한다. 따라서, 전역 영역에서 선언한 함수는 전역객체의 프로퍼티로 접근 가능한 전역 메소드이다.\r\n\r\n- 아래와 같이 echo라는 함수를 선언 시 echo는 전역 영역에서 선언되어 전역객체의 프로퍼티로 저장되어 echo()함수를 실행 시 전역객체의 프로퍼티를 호출한 것으로 this는 전역객체이다.\r\n\r\n  ```Javascript\r\n  function echo() {\r\n      console.log(this); //window\r\n  }\r\n\r\n  echo(); //window\r\n  window.echo(); //window\r\n  ```\r\n\r\n- 아래와 같이 내부 함수(`echo2`) 또는 함수 선언식(`echo3`)의 경우 echo함수의 property로 저장된 것이 아니므로 this는 전역 객체를 참조한다.\r\n\r\n  ```Javascript\r\n  function echo() {\r\n    console.log(this); //window\r\n    function echo2() {\r\n        console.log(this); //window\r\n    }\r\n    var echo3 = function () {\r\n        console.log(this); //window\r\n    }\r\n    echo2();\r\n    echo3();\r\n  }\r\n\r\n  echo();\r\n  ```\r\n\r\n- 이러한 this가 전역 객체를 바인딩하는 경우는 다음과 같다.\r\n  1. 전역 영역에서 선언한 함수\r\n  2. callback 함수\r\n  3. 메소드의 내부함수\r\n  4. 함수의 내부함수\r\n- 만약, 내부함수에서 this가 전역객체를 참조하는 것을 회피 하기 위해서는 다음과 같이 this를 저장한 변수를 객체내부에 저장하여 참조하는 방식으로 구현한다.\r\n\r\n```Javascript\r\nvar echoText = \"Global Echo\";\r\n\r\nvar obj = {\r\n    echoText : \"local Echo\",\r\n    echo : function () {\r\n        var pThis = this;\r\n\r\n        console.log(\"echo.this : \" + this); // obj\r\n        console.log(\"echo.echoText : \" + this.echoText); // local Echo\r\n        function ehoc2() {\r\n            console.log(\"echo2.this : \" + this); // window\r\n            console.log(\"echo2.echoText : \" + this.echoText); // Global Echo\r\n\r\n            console.log(\"pThis.this : \" + pThis); // obj\r\n            console.log(\"pThis.echoText : \" + pThis.echoText); // local Echo\r\n        }\r\n    }\r\n}\r\n\r\nobj.echo();\r\n```\r\n\r\n- 이러한 방식 외 apply, call, bind 메소드를 사용하여 this를 바인딩하는 방법이 존재한다.\r\n\r\n### 메소드 호출\r\n\r\n함수가 객체의 프로퍼티이면 메소드라고 지칭하며 해당 메소드를 호출 시 소유한 객체가 this에 바인딩 된다.\r\n\r\n```Javascript\r\nvar obj = {\r\n    echoText : \"object echo\",\r\n    echo : function() {\r\n        console.log(this);\r\n    }\r\n}\r\nobj.echo(); // obj\r\n```\r\n\r\n### 생성자 함수 호출\r\n\r\n함수를 new 연산자를 붙여서 호출하면 해당 함수는 생성자 함수라고 한다. 이러한 생성자 함수 호출 시 빈 객체를 생성하며 this는 새로 생성된 빈 객체를 가리키게 됩니다. 또한, 빈 객체의 프로토타입 객체의 경우 생성자 함수의 prototype 프로퍼티가 가르키는 객체가 됩니다.\r\n\r\n즉, 생성자 함수 호출의 경우 this는 자기자신이 됩니다.\r\n\r\n```Javascript\r\n// 생성자 함수\r\nfunction Person(name) {\r\n    this.name = name;\r\n}\r\n\r\nvar me = new Person('Lee');\r\nconsole.log(me); // Person {name: \"Lee\"} <-- this\r\n\r\n// new 연산자 없이 호출 시 일반함수로의 호출이므로, 반환값은 없으며 this의 경우 전역객체이다.\r\nvar you = Person('Kim');\r\nconsole.log(you); // undefined\r\nconsole.log(window.name); // Kim\r\n```\r\n\r\n### apply, call, bind 호출\r\n\r\n현재까지 this의 경우 함수가 호출되는 패턴에 의해 결정되었다. 이러한 암묵적인 결정대신 명시적인 결정이 되도록 해주는 방법이 apply, call, bind 메소드를 사용하는 것이다.\r\n\r\n- 3가지 메소드의 경우 Function.prototype 객체의 메소드이므로 모든 함수는 이를 호출 가능하다.\r\n\r\n#### apply, call\r\n\r\n호출하고자 하는 함수에 대하여 this를 인자로 넘기는 객체로 바인드하고 인자에 대해서는 아래와 같이 넘긴다.\r\n\r\n```Javascript\r\nvar Person = function (name) {\r\n    this.name = name;\r\n};\r\n\r\nvar foo = {};\r\n\r\n// apply 메소드는 생성자함수 Person을 호출한다. 이때 this에 객체 foo를 바인딩한다.\r\nPerson.apply(foo, ['name', 'name2', ...]); //인자를 배열로 전달\r\nPerson.call(foo, 'name', 'name2', ...); //인자를 하나씩 전달\r\n\r\nconsole.log(foo); // { name: 'name' }\r\n```\r\n\r\n#### bind\r\n\r\n호출하고자 하는 함수를 bind()로 호출 시 인자로 넘긴 this 값이 바인딩된 함수를 만들고 반환합니다.\r\n\r\n- 인자의 경우 call() 메소드와 같은 방식으로 인자를 전달합니다.\r\n\r\n```Javascript\r\nfunction fn() {\r\n    console.log(this);\r\n}\r\nvar obj = {\r\n    value: 5\r\n};\r\nvar boundFn = fn.bind(obj);\r\nboundFn(); // -> { value: 5 }\r\n```\r\n\r\n### 참고\r\n\r\n[this | PoiemaWeb](https://poiemaweb.com/js-this)\r\n\r\n[Function.prototype.bind()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)\r\n","excerpt":"함수 호출에 따른 this Javascript함수는 호출 될 때, 매개변수로 argument와 this를 암묵적으로 전달 받는다. Javascript에서의 this는 호출 될 때 인자로 전달받는 구조이므로, 호출 방식에 따라 this…","fields":{"slug":"/this/"},"frontmatter":{"date":"Mar 18, 2020","title":"Javascript this","tags":["this","Javascript"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2020 KAKAO BLIND RECRUITMENT] 문자열 압축</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.\r\n> - ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다.\r\n> - 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.\r\n> - 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return\r\n\r\n### 제한사항\r\n\r\n> - s의 길이는 1 이상 1,000 이하입니다.\r\n> - s는 알파벳 소문자로만 이루어져 있습니다.\r\n\r\n### 입출력 예\r\n\r\n> | s                          | result |\r\n> | -------------------------- | ------ |\r\n> | \"aabbaccc\"                 | 7      |\r\n> | \"ababcdcdababcdcd\"         | 9      |\r\n> | \"abcabcdede\"               | 8      |\r\n> | \"abcabcabcabcdededededede\" | 14     |\r\n> | \"xababcdcdababcdcd\"        | 17     |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(s) {\r\n  let answer = s; //문자열 그대로 반환\r\n  const cut_len = s.length / 2; //문자열 길이 / 2까지만 압축가능\r\n  const str_len = s.length; //문자열 길이만큼 loop 돌면서 자르는 단위 증가\r\n\r\n  for (\r\n    let i = 1;\r\n    i <= cut_len;\r\n    i++ //문자열 n개 단위 자르기(1~s.length/2)\r\n  ) {\r\n    let temp_str = ''; //임시로 압축한 문자열 저장하는 변수\r\n    let cut_str = s.slice(0, i); //최초 n개 단위로 자른 문자\r\n    let count = 1; //최초 문자열 자를 시 count 1로 초기화\r\n\r\n    for (\r\n      let j = i;\r\n      j < str_len;\r\n      j += i //문자열 길이만큼 loop(i만큼 증가)\r\n    ) {\r\n      const str = s.slice(j, j + i);\r\n      if (cut_str == str) {\r\n        //기준이 되는 문자와 같은 경우\r\n        count++; //숫자 증가\r\n      } //n개만큼 자른 문자가 반복되지 않는 경우\r\n      else {\r\n        temp_str += count > 1 ? count + cut_str : cut_str; //count 갯수를 기준으로 압축 문자 or 기존 문자 저장\r\n        cut_str = str; //기준 문자열을 새로운 n개만큼 자른 문자로 대체\r\n        count = 1; //count 갯수 초기화\r\n      }\r\n    }\r\n\r\n    if (cut_str) {\r\n      //for-loop 후 마지막 문자에 대하여 추가적으로 반영\r\n      temp_str += count > 1 ? count + cut_str : cut_str;\r\n    }\r\n\r\n    if (answer.length > temp_str.length) {\r\n      //압축문자가 더 작은 경우에만 answer 갱신\r\n      answer = temp_str;\r\n    }\r\n  }\r\n\r\n  return answer.length;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2020 KAKAO BLIND RECRUITMENT 문자열 압축 javascript 조건 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. ababcdcdababcdcd의 경우 문자를…","fields":{"slug":"/algorithm-compressstring/"},"frontmatter":{"date":"Mar 17, 2020","title":"문자열 압축(javascript)","tags":["알고리즘","프로그래머스","2020 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## 스코프(Scopre)\n\n어떠한 변수에 접근할 수 있는 범위\n\n- 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙\n- 만약, 스코프가 없다면 동일한 이름의 식별자는 1개만 존재가능\n- Javascript는 `렉시컬(지역) 스코프`를 사용, 함수를 `어디에 선언`하느냐에 따라 스코프가 결정. 호출 되는 시점과 무관\n\n### 스코프 구분\n\n- Javascript는 기본적으로 함수(function) 스코프를 가짐\n- ES6 문법인 let, const를 통해 블록(block) 스코프 형성 가능\n\n### 전역 스코프\n\n전역 스코프란? 함수 밖이나 `{}`밖에 선언되었을 때를 말한다.\n\n- 즉, 코드 어디에서든지 참조 가능한 것을 말한다.\n- 아래의 코드에서 echo()함수를 호출 시 함수 내에서 text변수를 호출하는데, 함수 스코프 안에서 text변수를 찾은 뒤 없으면 상위 스코프에서 찾게됩니다. 이를 스코프 체인(Scope Chain)이라고 합니다.\n\n  ```Javascript\n  /*전역 스코프*/\n  var text = \"Hello World!\"; //전역 변수\n  function echo() {\n    console.log(text); //전역 변수 text를 호출\n  }\n  console.log(text); //\"Hellow World!\"\n  echo(); //\"Hellow World!\"\n  ```\n\n- 위와 같이 전역 변수의 경우 global 객체에 변수가 저장되어, 타 라이브러리 사용 시 이름 중복문제 발생할 수도 있습니다.\n- Javascript의 경우 함수 스코프를 기본으로 가지기 때문에 만약, if문 안에 var로 선언된 변수가 있는 경우 전역 스코프를 가집니다.\n\n  ```Javascript\n  if (true) {\n    var text = \"Hello World!\"; //전역 변수\n  }\n  console.log(text); //\"Hellow World!\"\n  ```\n\n### 지역 스코프\n\n지역 스코프란 특정 부분에서만 사용 할 수 있는 것을 말합니다.\n\n- 이러한 지역 스코프의 경우 크게 2가지로 나뉘며 함수 스코프, 블럭 스코프라 합니다.\n\n  #### 함수 스코프\n\n  함수 안에서 선언한 식별자를 말하며 그 함수 내부에서만 사용가능 한 것을 말합니다.\n\n  - 만약, 전역과 지역에 동일한 이름의 2개의 변수가 존재 시 지역변수를 우선참조합니다.\n\n  ```Javascript\n  /*함수 스코프*/\n  function echo() {\n    var text = \"Hello World!\"; //지역 변수\n    console.log(text); //전역 변수 text를 호출\n  }\n  echo(); //\"Hello World!\"\n  console.log(text); //Uncaught ReferenceError: text is not defined\n\n  /*동일한 이름의 변수가 2개 존재 시*/\n  var text = \"global Hello World!\";\n  function echo() {\n    var text = \"local Hello World!\";\n    console.log(text); // \"local Hello World!\"\n  }\n  console.log(text); // \"global Hello World!\"\n  ```\n\n  #### 블록 스코프\n\n  중괄호(`{}`) 내부에서 `const`또는 `let`으로 변수를 선언 시 해당 변수의 경우 중괄호 블록내에서만 접근 할 수 있습니다.\n\n  ```Javascript\n  /*블록 스코프*/\n  if (true) {\n    var a = 1; //전역 변수\n    const b = 2; //블록 변수\n    let c = 3; //블록 변수\n    console.log(a); // 1\n    console.log(b); // 2\n    console.log(c); // 3\n  }\n\n  console.log(a); // 1\n  console.log(b); //Uncaught ReferenceError: b is not defined\n  console.log(c); //Uncaught ReferenceError: c is not defined\n  ```\n\n### 암묵적 전역\n\n함수안에서 선언되지 않은 변수에 값을 할당 시 전역 객체의 프로퍼티로 할당 됩니다. 또한, 변수가 아니라 프로퍼티로 추가됨으로 호스이스팅이 발생하지 않습니다.\n\n- 전역 변수는 delete로 삭제 불가, 전역 프로퍼티는 delete로 삭제 가능\n\n  ```Javascript\n  console.log(window.a); //undefined <- 호이스팅 발생\n  console.log(window.text); //ReferenceError: text is not defined <- 호이스팅 미발생\n\n  var a = 1; //전역 변수\n\n  function echo() {\n    //선언하지 않은 변수\n    text = \"Hello World!\"; //window.text로 property 추가 됨\n    console.log(text); //\"Hello World!\"\n  }\n\n  echo(); //\"Hello World!\"\n\n  console.log(window.a); //1\n  console.log(window.text); //\"Hello World!\"\n\n  delete a; //전역 변수임으로 삭제 X\n  delete text; //프로퍼티로 삭제 O\n\n  console.log(window.a); //1\n  console.log(window.text); //undefined\n  ```\n\n### 참고\n\n[Scope | PoiemaWeb](https://poiemaweb.com/js-scope)\n\n[[번역] 자바스크립트 스코프와 클로저(JavaScript Scope and Closures)](https://medium.com/@khwsc1/%EB%B2%88%EC%97%AD-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8A%A4%EC%BD%94%ED%94%84%EC%99%80-%ED%81%B4%EB%A1%9C%EC%A0%80-javascript-scope-and-closures-8d402c976d19)\n","excerpt":"스코프(Scopre) 어떠한 변수에 접근할 수 있는 범위 참조 대상 식별자(identifier…","fields":{"slug":"/Scope/"},"frontmatter":{"date":"Mar 16, 2020","title":"스코프(Scope)","tags":["Scope","스코프","Javascript"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2018 KAKAO BLIND RECRUITMENT][1차] 다트게임</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> 1. 다트 게임은 총 3번의 기회로 구성된다.\r\n> 2. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.\r\n> 3. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.\r\n> 4. 옵션으로 스타상(_) , 아차상(#)이 존재하며 스타상(_) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.\r\n> 5. 스타상(_)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(_)의 점수만 2배가 된다. (예제 4번 참고)\r\n> 6. 스타상(_)의 효과는 다른 스타상(_)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(\\*) 점수는 4배가 된다. (예제 4번 참고)\r\n> 7. 스타상(\\*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)\r\n> 8. Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.\r\n> 9. 스타상(\\*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.\r\n\r\n### 제한사항\r\n\r\n> - 점수는 0에서 10 사이의 정수이다.\r\n> - 보너스는 S, D, T 중 하나이다.\r\n> - 옵선은 \\*이나 # 중 하나이며, 없을 수도 있다.\r\n\r\n### 입출력 예\r\n\r\n> | 예제 | dartResult | answer | 설명                                                            |\r\n> | ---- | ---------- | ------ | --------------------------------------------------------------- |\r\n> | 1    | 1S2D\\*3T   | 37     | 1<sup>1</sup> \\* 2 + 2<sup>2</sup> \\* 2 + 3<sup>3</sup>         |\r\n> | 2    | 1D2S#10S   | 9      | 1<sup>2</sup> + 2<sup>1</sup> \\* (-1) + 10<sup>1</sup>          |\r\n> | 3    | 1D2S0T     | 3      | 1<sup>2</sup> + 2<sup>1</sup> + 0<sup>3</sup>                   |\r\n> | 4    | 1S*2T*3S   | 23     | 1<sup>1</sup> \\* 2 \\* 2 + 2<sup>3</sup> \\* 2 + 3<sup>1</sup>    |\r\n> | 5    | 1D#2S\\*3S  | 5      | 1<sup>2</sup> \\* (-1) \\* 2 + 2<sup>1</sup> \\* 2 + 3<sup>1</sup> |\r\n> | 6    | 1T2D3D#    | -4     | 1<sup>3</sup> + 2<sup>2</sup> + 3<sup>2</sup> \\* (-1)           |\r\n> | 7    | 1D2S3T\\*   | 59     | 1<sup>2</sup> + 2<sup>1</sup> \\* 2 + 3<sup>3</sup> \\* 2         |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(dartResult) {\r\n  //점수 - [정수][S|D|T]\r\n  //옵션 - * | # | \"\"\r\n  //Math.pow(x,y) x의 y제곱\r\n  let stack = []; //다트 점수를 넣을 배열(총 길이 : 3)\r\n  let score = { S: 1, D: 2, T: 3 }; //영역에 따른 제곱 수\r\n  let count = 0; //숫자 영역을 체크하기 위한 count 값(10인 경우)\r\n  const len = dartResult.length;\r\n\r\n  //dartResult길이만큼 loop\r\n  for (let i = 0; i < len; i++) {\r\n    let data = dartResult.charAt(i);\r\n    if (+data != data) {\r\n      //number로 변환 시 현재 text와 동일한지 판단(문자인 경우 NaN)\r\n      if (score[data]) {\r\n        //현재 문자가 영역인 경우\r\n        stack.push(Math.pow(dartResult.slice(i - count, i), score[data]));\r\n        count = 0;\r\n      } else {\r\n        const invariable = data === '*' ? 2 : -1; //스타상, 아차상에 따른 상수 설정\r\n        const len = stack.length; //자주 사용되는 점수배열의 길이 값을 변수로 할당\r\n        if (invariable == 2 && len > 1) {\r\n          //스타상인 경우 앞의 값도 2배를 해줘야함으로 현재 몇 번째 기회인지를 체크한다.\r\n          stack[len - 2] = stack[len - 2] * invariable;\r\n        }\r\n        stack[len - 1] = stack[len - 1] * invariable; //스타상, 아차상 둘 다 동일하게 현재 점수에 대하여 곱하기 연산 수행\r\n      }\r\n    } else {\r\n      count++; //숫자 영역 체크를 위한 카운트\r\n    }\r\n  }\r\n\r\n  return stack.reduce((acc, value) => acc + value, 0); //배열의 합 반환\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 다트게임 javascript 조건 다트 게임은 총 3번의 기회로 구성된다. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 점수와 함께 Single(S), Double(D), Triple…","fields":{"slug":"/algorithm-dartgame/"},"frontmatter":{"date":"Mar 15, 2020","title":"다트게임(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2019 KAKAO BLIND RECRUITMENT] 실패율</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 실패율은 다음과 같이 정의한다.\r\n>   - 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수\r\n> - 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하라\r\n\r\n### 제한사항\r\n\r\n> - 스테이지의 개수 N은 1 이상 500 이하의 자연수이다.\r\n> - stages의 길이는 1 이상 200,000 이하이다.\r\n> - stages에는 1 이상 N + 1 이하의 자연수가 담겨있다.\r\n>   - 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.\r\n>   - 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.\r\n> - 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.\r\n> - 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다.\r\n\r\n### 입출력 예\r\n\r\n> | N   | stages                   | result      |\r\n> | --- | ------------------------ | ----------- |\r\n> | 5   | [2, 1, 2, 6, 2, 4, 3, 3] | [3,4,2,1,5] |\r\n> | 4   | [4,4,4,4,4]              | [4,1,2,3]   |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(N, stages) {\r\n  var answer = [];\r\n  var stack = [];\r\n  let users = stages.length;\r\n  //[] {stage, 실패율}\r\n  for (var i = 1; i <= N; i++) {\r\n    const len = stages.filter(value => value === i).length;\r\n    if (len === 0) {\r\n      stack.push({ index: i, ratio: 0 });\r\n    } else {\r\n      stack.push({ index: i, ratio: len / users });\r\n      users -= len;\r\n    }\r\n  }\r\n\r\n  stack.sort((a, b) => {\r\n    if (b.ratio === a.ratio) {\r\n      return a.index - b.index;\r\n    } else {\r\n      return b.ratio - a.ratio;\r\n    }\r\n  });\r\n\r\n  return stack.map(value => value.index);\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2019 KAKAO BLIND RECRUITMENT 실패율 javascript 조건 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N…","fields":{"slug":"/algorithm-failrate/"},"frontmatter":{"date":"Mar 15, 2020","title":"실패율(javascript)","tags":["알고리즘","프로그래머스","2019 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2018 KAKAO BLIND RECRUITMENT][1차] 비밀지도</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> 1. 지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 공백(\" ) 또는벽(#\") 두 종류로 이루어져 있다.\r\n> 2. 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 지도 1과 지도 2라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.\r\n> 3. 지도 1과 지도 2는 각각 정수 배열로 암호화되어 있다.\r\n> 4. 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.\r\n\r\n### 제한사항\r\n\r\n> - 1 ≦ n ≦ 16\r\n> - arr1, arr2는 길이 n인 정수 배열로 주어진다.\r\n> - 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.\r\n\r\n### 입출력 예\r\n\r\n> | 매개변수 | 값                                          |\r\n> | -------- | ------------------------------------------- |\r\n> | n        | 5                                           |\r\n> | arr1     | [9, 20, 28, 18, 11]                         |\r\n> | arr2     | [30, 1, 21, 17, 28]                         |\r\n> | 출력     | [\"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\"] |\r\n\r\n> | 매개변수 | 값                                                         |\r\n> | -------- | ---------------------------------------------------------- |\r\n> | n        | 6                                                          |\r\n> | arr1     | [46, 33, 33 ,22, 31, 50]                                   |\r\n> | arr2     | [27 ,56, 19, 14, 14, 10]                                   |\r\n> | 출력     | [\"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \"] |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(n, arr1, arr2) {\r\n  var answer = [];\r\n  const len = arr1.length;\r\n\r\n  //arr1의 row개수(== n)만큼 loop\r\n  for (let i = 0; i < len; i++) {\r\n    //10진수 -> 2진수\r\n    let arr1_row = arr1[i].toString(2);\r\n    let arr2_row = arr2[i].toString(2);\r\n\r\n    //2진수로 변경 시 앞의 0이 제외된 부분 추가\r\n    if (arr1_row.length < n) {\r\n      arr1_row = '0'.repeat(n - arr1_row.length) + arr1_row;\r\n    }\r\n    if (arr2_row.length < n) {\r\n      arr2_row = '0'.repeat(n - arr2_row.length) + arr2_row;\r\n    }\r\n\r\n    //숫자 -> 문자(# || \" \")로 변경\r\n    let str_temp = '';\r\n    for (let j = 0; j < len; j++) {\r\n      if (Math.max(arr1_row.charAt(j), arr2_row.charAt(j)) == 1) str_temp += '#';\r\n      else str_temp += ' ';\r\n    }\r\n    answer.push(str_temp);\r\n  }\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 비밀지도 javascript 조건 지도는 한 변의 길이가 n…","fields":{"slug":"/algorithm-screatmap/"},"frontmatter":{"date":"Mar 13, 2020","title":"비밀지도(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## <center>[2018 KAKAO BLIND RECRUITMENT][1차] 캐시</center>\r\n\r\n**<center>javascript</center>**\r\n\r\n---\r\n\r\n### 조건\r\n\r\n> - 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.\r\n>\r\n> - cache hit일 경우 실행시간은 1이다.\r\n>\r\n> - cache miss일 경우 실행시간은 5이다.\r\n\r\n### 제한사항\r\n\r\n> - 캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.\r\n> - cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.\r\n> - cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.\r\n> - 각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.\r\n\r\n### 입출력 예\r\n\r\n> | 캐시크기(cacheSize) | 도시이름(cities)                                                                          | 실행시간 |\r\n> | ------------------- | ----------------------------------------------------------------------------------------- | -------- |\r\n> | 3                   | [Jeju, Pangyo, Seoul, NewYork, LA, Jeju, Pangyo, Seoul, NewYork, LA]                      | 50       |\r\n> | 3                   | [Jeju, Pangyo, Seoul, Jeju, Pangyo, Seoul, Jeju, Pangyo, Seoul]                           | 21       |\r\n> | 2                   | [Jeju, Pangyo, Seoul, NewYork, LA, SanFrancisco, Seoul, Rome, Paris, Jeju, NewYork, Rome] | 60       |\r\n> | 5                   | [Jeju, Pangyo, Seoul, NewYork, LA, SanFrancisco, Seoul, Rome, Paris, Jeju, NewYork, Rome] | 52       |\r\n> | 2                   | [Jeju, Pangyo, NewYork, newyork]                                                          | 16       |\r\n> | 0                   | [Jeju, Pangyo, Seoul, NewYork, LA]                                                        | 25       |\r\n\r\n### 코드\r\n\r\n```javascript\r\nfunction solution(cacheSize, cities) {\r\n  var answer = 0;\r\n  let cache = [];\r\n\r\n  //LRU(페이지 교체 알고리즘) : 가장 마지막에 사용 된 페이지를 교체\r\n  const cities_len = cities.length;\r\n\r\n  if (cacheSize == 0) return cities_len * 5; //캐시크기가 0인 경우 전부 실행시간이 5이기 때문에 반환\r\n\r\n  //도시 개수만큼 loop\r\n  for (let i = 0; i < cities_len; i++) {\r\n    const citie = cities[i].toLowerCase(); //도시 이름\r\n    if (cache.indexOf(citie) !== -1) {\r\n      //cache hit\r\n      answer += 1; //1초 추가\r\n      cache.splice(cache.indexOf(citie), 1); //hit 된 도시 배열에서 제거\r\n      cache.push(citie); //가장 최근에 hit됨으로 마지막 index에 위치\r\n    } //cache miss\r\n    else {\r\n      if (cache.length < cacheSize) {\r\n        //cache max size 미 도달\r\n        cache.push(citie);\r\n      } //LRU Logic 실행\r\n      else {\r\n        cache.shift(); //가장 마지막에 사용된 페이지 제거\r\n        cache.push(citie); //새로운 페이지 추가\r\n      }\r\n      answer += 5;\r\n    }\r\n  }\r\n  return answer;\r\n}\r\n```\r\n\r\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\r\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 캐시 javascript 조건 캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다. cache hit일 경우 실행시간은 1이다. cache miss일 경우 실행시간은…","fields":{"slug":"/algorithm-cache/"},"frontmatter":{"date":"Mar 12, 2020","title":"캐시(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\n## Fetch API 학습\n\n---\n\n### 개념\n\n- 기존 XMLHttpRequest(이하 XHR)를 대체하는 개념으로 Request나 Response를 포함하며 결과값으로 Promise객체를 반환합니다.\n- XHR에서 Response를 확인하기 위하여 callback이나 event를 사용하던 부분을 .then(), .catch()를 사용하여 확인합니다.\n- ajax와 유사해 보이지만 다른 부분이 존재\n  1. 결과값인 Promise 객체는 HTTP error 상태를 reject하지 않음\n     - Status Code가 404나 500인 경우 resolve처리. ok상태가 false인 resolve를 반환\n     - 네트워크 장애, 요청 미완료 시 reject 반환\n  2. 쿠키를 보내거나 받지 않음\n     - CORS 및 쿠키 사용시에는 Header에 credentials 속성을 설정해줘야 함\n- 미지원 브라우저의 경우 [Fetch Polyfill](https://github.com/github/fetch)사용하여 구현가능\n\n### 문법\n\n1.  Syntax\n\n    ```Javascript\n    fetch(URL, [option]);\n    //URL : 통신 요청할 서버주소\n    //option : 객체를 넘기며 method, headers, body... 와 같은 properyt를 설정한다.\n    ```\n\n2.  사용법\n\n    아래와 같이 URL을 입력 후 성공, 실패에 대한 동작정의를 then(), catch() 메소드를 사용하여 처리한다.\n\n    ```Javascript\n    fetch(URL, [option]);\n    //Get방식\n    fetch('http://example.com/movies.json') //서버 주소를 첫 번째 인자로 넘김\n    .then(res => console.log(res)) //통신 성공 시 수행 할 코드\n    .catch(err => console.log(err)); //error 발생 시 예외처리 할 코드\n\n    //Post방식\n    const option = {\n      method : \"POST\",\n      body : ...,\n      header : {}\n    }\n    fetch('http://example.com/movies.json', option) //두 번째 인자에 객체를 인자로 전달한다\n    .then(res => console.log(res)) //통신 성공 시 수행 할 코드\n    .catch(err => console.log(err)); //error 발생 시 예외처리 할 코드\n    ```\n\n### 관련 인터페이스\n\n1.  Headers\n\n    - Headers() 생성자를 사용해 헤더 객체를 생성가능\n    - Key와 Value로 이루어진 multi-map구조\n\n      ```Javascript\n      //1. set(), append() 메소드를 사용하여 property 추가\n      var myHeaders = new Headers();\n      myHeaders.set(\"Content-Type\", \"text/plain\"); //기존의 동일한 property가 존재시 덮어쓰기\n      myHeaders.append(\"Content-Length\", \"Hello World\".length.toString());\n      myHeaders.append(\"X-Custom-Header\", \"ProcessThisImmediately\");\n      //2. 생성자에 인자로 전달\n      myHeaders = new Headers({\n      \"Content-Type\": \"text/plain\",\n      \"Content-Length\": \"Hello World\".length.toString(),\n      \"X-Custom-Header\": \"ProcessThisImmediately\",\n      });\n\n      //3. has(), get(), getAll() 메소드로 value 확인\n      myHeaders.has(\"Content-Type\") // true\n      myHeaders.has(\"Set-Cookie\") // false\n      myHeaders.get(\"Content-Length\") // 11\n      myHeaders.append(\"X-Custom-Header\", \"AnotherValue\");\n      myHeaders.getAll(\"X-Custom-Header\") // [\"ProcessThisImmediately\", \"AnotherValue\"]\n\n      //4. delete()로 삭제\n      myHeaders.delete(\"X-Custom-Header\");\n      ```\n\n2.  Request\n\n    - fetch()에 직접 URL, option을 입력하는 것을 대체해준다.\n\n      ```Javascript\n      //Request(URL, [option])\n      //URL : 서버 주소\n      //option : method, headers, body... etc fetch의 두 번째 인자를 대체\n      const req = new Request(\"/api/posts\", {\n      method: \"GET\",\n      headers: new Headers({ //Headers 인터페이스 사용 or 직접 객체입력\n      \"content-type\": \"application/json\",\n      }),\n      body: { //Body 인터페이스로 대체 가능\n      name: \"LeeHanur\",\n      }\n      });\n\n      fetch(req)\n      .then(res => console.log(res))\n      .catch(err => console.log(err);\n      ```\n\n3.  Response\n\n    - fetch()에서는 resolve 됬을 때 Response 인스턴스를 반환한다.\n    - 생성자로 객체 생성하여 사용 가능하나 ServiceWorkers에서 사용할 것이 아니면 굳이 생성하지 않는다.\n\n      ```Javascript\n      //Response 상수\n\n      Response.status //HTTP Status의 정수치, 기본값 200\n      Response.statusText //HTTP Status 코드의 메서드와 일치하는 문자열, 기본값은 \"OK\"\n      Response.ok //HTTP Status 코드가 200~299 값 인지에 대하여 Boolean를 반환\n\n      var myResponse = new Response(body, [init]);\n      //body : null 허용, Blob|BufferSource... etc 응답된 body의 type을 정의\n      //init : status, statusText, headers 3가지 property 설정가능\n\n      var myBlob = new Blob();\n      var init = { \"status\" : 200 , \"statusText\" : \"SuperSmashingGreat!\" };\n      var myResponse = new Response(myBlob,init);\n      ```\n\n4.  body\n\n    - Request, Response 둘 다 Body를 가지고 있으며, body는 아래에서 기술한 타입들 중 하나의 인스턴스입니다.\n\n      - ArrayBuffer\n      - ArrayBufferView (Uint8Array같은 TypedArray)\n      - [Blob](https://developer.mozilla.org/ko/docs/Web/API/Blob)/File\n      - 문자열\n      - [URLSearchParams](https://developer.mozilla.org/ko/docs/Web/API/URLSearchParams)\n      - [FormData](https://developer.mozilla.org/ko/docs/Web/API/FormData)\n\n      ```Javascript\n      var form = new FormData(document.getElementById('login-form'));\n      fetch(\"/login\", {\n      method: \"POST\",\n      body: form\n      })\n      ```\n\n### 참고\n\n- [Using Fetch](https://developer.mozilla.org/ko/docs/Web/API/Fetch_API/Fetch%EC%9D%98_%EC%82%AC%EC%9A%A9%EB%B2%95)\n\n- [Javascript Fetch API](https://medium.com/@kkak10/javascript-fetch-api-e26bfeaad9b6)\n","excerpt":"Fetch API 학습 개념 기존 XMLHttpRequest(이하 XHR)를 대체하는 개념으로 Request나 Response를 포함하며 결과값으로 Promise객체를 반환합니다. XHR에서 Response를 확인하기 위하여 callback…","fields":{"slug":"/fetch API/"},"frontmatter":{"date":"Mar 11, 2020","title":"fetch API","tags":["fetch","Javascript"]}}},{"node":{"rawMarkdownBody":"\n## <center>[2018 KAKAO BLIND RECRUITMENT][3차] 파일명 정렬</center>\n\n**<center>javascript</center>**\n\n---\n\n### 조건\n\n> - files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.\n>\n> - 각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(\" ), 마침표(.), 빼기 부호(-\")만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.\n>\n> - 중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.)\n\n### 제한사항\n\n> 파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다.\n>\n> - HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.\n> - NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다.\n> - TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.\n>\n> | 파일명           | HEAD | NUMBER | TAIL        |\n> | ---------------- | ---- | ------ | ----------- |\n> | foo9.text        | foo  | 9      | .txt        |\n> | foo010bar020.zip | foo  | 010    | bar020.zip  |\n> | F-15             | F-   | 15     | (빈 문자열) |\n>\n> 파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.\n>\n> - 파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. MUZI와 muzi, MuZi는 정렬 시에 같은 순서로 취급된다.\n> - 파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 < 10 < 0011 < 012 < 13 < 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.\n> - 두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. MUZI01.zip과 muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.\n\n### 입출력 예\n\n> 입력: [img12.png, img10.png, img02.png, img1.png, IMG01.GIF, img2.JPG]\n>\n> 출력: [img1.png, IMG01.GIF, img02.png, img2.JPG, img10.png, img12.png]\n\n> 입력: [F-5 Freedom Fighter, B-50 Superfortress, A-10 Thunderbolt II, F-14 Tomcat]\n>\n> 출력: [A-10 Thunderbolt II, B-50 Superfortress, F-5 Freedom Fighter, F-14 Tomcat]\n\n### 코드\n\n```javascript\nfunction solution(files) {\n  let answer = [];\n  //HEAD, NUMBER, TAIL 구분\n  //NUMBER를 기준으로 앞/뒤 구분 search(정규식)\n  let len = files.length;\n  const reg = /(\\d+)/g; //숫자가 1개이상 매칭되는 정규식(메모리 고려)\n  for (let i = 0; i < len; i++) {\n    answer.push({ index: i, value: files[i].split(reg) }); //[{index:0~n, value:[HEAD, NUMBER, TAIL]}]\n  }\n\n  //sort의 0은 유지 but ECMAscript 명세에 따라 보장은 하지않음(index로 순서보장)\n  answer.sort((a, b) => {\n    //HEAD의 값을 비교\n    const a_head = a.value[0].toLowerCase();\n    const b_head = b.value[0].toLowerCase();\n    if (a_head < b_head) return -1;\n    else if (a_head > b_head) return 1;\n    else {\n      //HEAD가 같은경우 NUMBER를 비교\n      const a_number = Number(a.value[1]); //Number로 앞의 0을 제거\n      const b_number = Number(b.value[1]);\n      if (a_number > b_number) return 1;\n      else if (a_number < b_number) return -1;\n      else {\n        //HEAD, NUMBER가 같은 경우 index로 순서보장\n        if (a.index < b.index) return -1;\n        else return 1;\n      }\n    }\n  });\n\n  return answer.map(obj => obj.value.join(''));\n}\n```\n\n출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges\n","excerpt":"2018 KAKAO BLIND RECRUITMENT 파일명 정렬 javascript 조건 files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다. 각 파일명은 10…","fields":{"slug":"/algorithm-filename-sort/"},"frontmatter":{"date":"Mar 10, 2020","title":"파일명 정렬(javascript)","tags":["알고리즘","프로그래머스","2018 KAKAO BLIND RECRUITMENT"]}}},{"node":{"rawMarkdownBody":"\r\n## window.open()시 width, height값이 설정한 값과 다른 현상\r\n\r\n- window의 내장함수인 open()을 사용 시 브라우저별로 값이 다르게 나타나는 현상\r\n\r\n### 문법\r\n\r\n```javascript\r\nwindow.open(URL, name, specs, replace);\r\n```\r\n\r\n- specs에 \"width=pixels\", \"height=pixels\"값을 입력하여 크기를 설정 가능합니다.\r\n\r\n```javascript\r\nwindow.resizeTo(aWidth, aHeight);\r\n```\r\n\r\n- aWidth, aHeight 설정 시 window의 outerWidth, outerHeight값이 설정한 값으로 변경됩니다.\r\n\r\n### 현상\r\n\r\n- 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\r\n  ([**샘플**](https://angwangho.github.io/sampleFile/window_method/open_main.html))\r\n\r\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/window_method/open_main.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\r\n\r\n- 최초 확인 시 IE11, Edge, chorme(win10/win8), Opera 브라우저에서 설정한 값과 다르게 크기가 설정되는 것을 확인하였습니다.(2019.11.20기준)\r\n  - window open() 시 window의 innerWidth,innerHight값이 specs에서 설정한 width, height값과 같아야 합니다.\r\n- window.resizeTo() 함수 사용 시 Edge 브라우저에서 값이 다르게 설정 됩니다.\r\n\r\n### 해결방안\r\n\r\n1. 변경 후 값 재보정\r\n   - 얼만큼 잘못된 값이 설정될지는 실행 전 알 수 없습니다.\r\n   - 이에 대하여 설정 된 후 보정을 통하여 원하는 값으로 설정되도록 합니다.\r\n     - resize event에서 설정 값, outer/inner의 차이를 통해 값 보정\r\n","excerpt":"window.open()시 width, height값이 설정한 값과 다른 현상 window의 내장함수인 open()을 사용 시 브라우저별로 값이 다르게 나타나는 현상 문법 specs에 \"width=pixels\", \"height=pixels…","fields":{"slug":"/open-Bug/"},"frontmatter":{"date":"Mar 09, 2020","title":"window.open()시 width, height값이 설정한 값과 다른 현상","tags":["open","window.open","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\r\n## window의 내장함수인 alert()을 사용 시 브라우저별로 script 처리 및 event가 다른 현상\r\n\r\n### 문법\r\n\r\n```javascript\r\nwindow.alert([message]) | alert([message]);\r\n//message에 경고 대화상자 창에 표시할 텍스트를 입력합니다.\r\n```\r\n\r\n### 현상\r\n\r\n- 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\r\n  ([**샘플**](https://angwangho.github.io/sampleFile/window_method/alert.html))\r\n\r\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/window_method/alert.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\r\n\r\n- mousedown event에서 alert()을 실행 시 브라우저 별 event 발생이 다르며 script 처리 방식에 차이가 존재합니다.\r\n\r\n  - IE11, Edge와 같이 OS, 브라우저 버전에 따라 차이가 존재합니다.\r\n\r\n- 브라우저별 확인 결과 크게 3가지로 분류가 가능합니다.\r\n  1. event 미발생 : mouseup event가 발생 X\r\n     - chrome, IE11(win7)\r\n  2. event 발생 : alert 실행 중 mouseup event가 발생\r\n     - IE11(win10), Edge(18)\r\n     - Edge(18)의 경우 mouseup event가 발생하나 alert, confirm를 실행 시 해당 동작이 수행되지 않습니다.\r\n  3. event block 후 발생 : alert 창이 닫힌 후 event 발생\r\n     - FireFox\r\n\r\n### 해결방안\r\n\r\n1. 실행 시점 변경\r\n   - alert 발생 시 창이 닫혔는지 알 수 있는 방안이 없으며, 브라우저 별 script처리 및 event 발생 차이가 존재\r\n   - 실행 시점을 mouseup, click event으로 변경하여 호출\r\n","excerpt":"window의 내장함수인 alert()을 사용 시 브라우저별로 script 처리 및 event가 다른 현상 문법 현상 현상 확인의 경우 하단의 iframe 또는 샘플링크에서 확인 가능합니다\n(샘플) mousedown event에서 alert…","fields":{"slug":"/alert-Bug/"},"frontmatter":{"date":"Mar 08, 2020","title":"alert 사용 시 브라우저별 script처리 및 event가 다른 현상","tags":["alert","Browser Bug"]}}},{"node":{"rawMarkdownBody":"\r\n## React.js에 typescript 적용하기\r\n\r\n---\r\n\r\n- React 공식 사이트를 참고하여 진행하였습니다.\r\n\r\n  [Static Type Checking - React](https://ko.reactjs.org/docs/static-type-checking.html#using-typescript-with-create-react-app)\r\n\r\n### 프로젝트 설치\r\n\r\n- 생성하고자하는 위치에서 프로젝트이름을 원하는 이름으로 넣은 후 아래 명령어를 터미널에서 입력한다.\r\n\r\n  ```Shell\r\n    npx create-react-app '프로젝트이름' --template typescript\r\n  ```\r\n\r\n- 만약, app.js 즉, 기본 실행 페이지가 없으며 아래와 같은 text가 발생한 경우\r\n\r\n  > template was not provided. This is likely because you're using an outdated version of create-react-app.\r\n  > Please note that global installs of create-react-app are no longer supported.\r\n\r\n- 아래 명령어를 실행하여 global로 설치된 react-app을 제거 후 시작한다.\r\n\r\n  ```Shell\r\n    npm uninstall -g create-react-app\r\n  ```\r\n\r\n- 만약, Mac 환경에서 src가 생성이 안된 경우는 다음과 같이 명령어를 실행 후 생성된다\r\n\r\n  ```Shell\r\n  npm rm -g create-react-app #old 버전 제거\r\n  sudo npm install -g create-react-app #sudo로 해야 권한 에러 미발생\r\n  ```\r\n\r\n- 정상적으로 설치 시 아래와 같은 디렉토리 구조를 가진다.\r\n\r\n  ![Alternate text][directory]\r\n\r\n- 아래 명령어를 입력하여 프로젝트를 실행한다.\r\n\r\n  ```Shell\r\n  cd '프로젝트이름'\r\n  npm start\r\n  ```\r\n\r\n  - 실행 시 다음과 같은 화면을 확인할 수 있다.👏\r\n\r\n    ![Alternate text][runview]\r\n\r\n### 실행 및 테스트\r\n\r\n- typescript가 적용되고 있는지 간단히 확인하기 위하여 Header.tsx라는 파일을 생성하여 다음과 같은 코드를 작성\r\n\r\n  ```javascript\r\n  //Header.tsx\r\n  import React from \"react\";\r\n\r\n  function Header(props: { title: string }) {\r\n  const test = parseInt(props.title, 10) as Number; // or const test: Number = parseInt(props.title, 10)\r\n  return <div>{test}</div>;\r\n  }\r\n\r\n  export default Header;\r\n\r\n  //App.tsx\r\n  import React from \"react\";\r\n  import \"./App.css\";\r\n  import Header from \"./Header\";\r\n\r\n  function App() {\r\n  return (\r\n\r\n  <div className=\"App\">\r\n  <header className=\"App-header\">\r\n  <Header title=\"1234\" />\r\n  </header>\r\n  </div>\r\n  );\r\n  }\r\n\r\n  export default App;\r\n  ```\r\n\r\n- App.tsx에서 기존의 태그들을 삭제 후 Header라는 함수형 컴포넌트에 title property에 값을 넣어 typescript를 테스트하고자 합니다.\r\n\r\n- 현재, 코드상 title에 string값을 인자로 넘겨주고 있습니다. 만약, string이 아닌 값을 넣어 줄 시 tool상에서 다음과 같은 error를 표시합니다.\r\n\r\n  ![Alternate text][syntax_error]\r\n\r\n- 다시 원래대로 문자열을 넘겨주도록 되돌린 후 실행 시 다음과 같이 적용된 것을 확인 할 수 있습니다.\r\n\r\n  ![Alternate text][updateview]\r\n\r\n- typescript 사용시 자세한 문법이나 type의 경우 다음 링크를 참조하여 작업하기 바랍니다.\r\n\r\n  [TypeScript 한글 문서](https://typescript-kr.github.io/pages/Basic%20Types.html)\r\n\r\n[directory]: image1.png '폴더구조'\r\n[runview]: image2.png '실행결과'\r\n[syntax_error]: image3.png '문법에러'\r\n[updateview]: image4.png '수정결과화면'\r\n","excerpt":"React.js에 typescript 적용하기 React 공식 사이트를 참고하여 진행하였습니다. Static Type Checking - React…","fields":{"slug":"/React-typescript.md/"},"frontmatter":{"date":"Mar 07, 2020","title":"React.js에 typescript 적용하기","tags":["React.js","typescript"]}}},{"node":{"rawMarkdownBody":"\n## React.js의 Hook에 대해서 학습 및 사용법\n\n---\n\n- 학습의 경우 공식 홈페이지를 참고하여 진행([**공식홈페이지**](https://ko.reactjs.org/docs/hooks-intro.html)).\n- React 버전 16.8.0이상, React Native 0.59이상에서 지원\n\n### 등장 배경\n\n- 기존 React에서 state를 사용하기 위해서는 class형태에서 React.component를 상속하여 사용\n- 상속 없이 import 방식으로 Function이나 const같은 함수에서 state 사용할 수 있도록 지원하는 개념\n- 함수 컴포넌트에서 React state와 생명주기 기능(lifecycle features)을 “연동(hook into)“할 수 있게 해주는 함수.\n\n### 개념\n\n- state를 사용하기 위해 class를 사용하는데 이를 대체하여 class가 아니여도 state관리 및 rife-cycle사용이 가능하게 해주는 API\n- 좀 더 재사용 가능한 컴포넌트를 작성하는데 도움을 주기 위해 나옴\n- class안에서는 동작하지 않음\n\n### 문법\n\n- 중복하여 사용 가능(state, effect 동일)\n\n1.  State Hook\n\n    - state를 대체하는 개념으로 useState를 react로 부터 import하여 사용\n\n    - useState는 2개의 항목을 가지는 배열을 반환. 인자로 주는 값의 경우 초기 변수 값을 나타낸다.\n\n      > 💡 return [현재 변수값, 변수를 바꾸는 setter 함수];\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      import React, { useState } from 'react'; //useState가 hook\n\n      function Example() {\n        // \"count\"라는 새 상태 변수를 선언합니다\n        const [count, setCount] = useState(0); //useState는 중복하여 호출가능(각자 독립된 state를 가짐)\n        const [fruit, setFruit] = useState('banana');\n        const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);\n\n        return (\n          <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>Click me</button>\n          </div>\n        );\n      }\n      ```\n\n      </details>\n\n2.  Effect Hook\n\n    - 'Data를 가져와 DOM을 수정하는 작업'을 'side effects' or 'effects'라고 한다. 이러한 작업들을 함수 컴포넌트에서 Hook을 사용해서 수행 가능하도록 하는 것을 말한다.\n\n    - class의 생명주기 함수에서 제공되는 부분들에 대해서 제공하는 것(componentDidMount, componentDidUpdate, componentWillUnmount를 대체)\n\n    - props, state에 접근이 가능하며, 매 랜더링 후 실행 됨(최초 로딩 포함)\n\n    - 기존 class 구조에서는 생명주기 메서드 각각에 로직을 작성했으나 Effect Hook에서는 한 곳에서 로직관리 가능\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      import React, { useState, useEffect } from 'react';\n\n      function Example() {\n        const [count, setCount] = useState(0);\n\n        // componentDidMount, componentDidUpdate와 비슷합니다\n        useEffect(() => {\n          // 브라우저 API를 이용해 문서의 타이틀을 업데이트합니다\n          document.title = `You clicked ${count} times`; //DidMount, DidUpdate를 대체\n\n          return () => {\n            //willUnmount를 대체\n            //cdoe...\n          };\n        });\n\n        return (\n          <div>\n            <p>You clicked {count} times</p>\n            <button onClick={() => setCount(count + 1)}>Click me</button>\n          </div>\n        );\n      }\n      ```\n\n      </details>\n\n    - 구독을 계속 갱신,취소하는데 이는 과도한 비용을 초래합니다. 이를 방지하고자 값이 변경 됬을 때만 새로운 구독을 생성하면 되는데 useEffect 두 번째 인자를 전달하여 사용할 것(props.source)\n\n      ```javascript\n      useEffect(\n        () => {\n          const subscription = props.source.subscribe();\n          return () => {\n            subscription.unsubscribe();\n          };\n        },\n        [props.source] //Option : [] 값 입력 시 DidMount/WillUnmount효과, 값이 있는 경우 변경 된 경우에만 코드 수행\n      );\n      ```\n\n3.  Context Hook\n\n    - context 객체(React.createContext에서 반환된 값)을 받아 그 context의 현재 값을 반환합니다. context의 현재 값은 트리 안에서 이 Hook을 호출하는 컴포넌트에 가장 가까이에 있는 <MyContext.Provider>의 value prop에 의해 결정됩니다.\n    - react.js의 context를 hook API화 시킨 개념\n\n      **Context란?**\n\n      - 하위 컴포넌트에 값을 전달하기 위해서는 props를 사용하여 넘겨주어야 하는데, 이를 사용하지 않고 값을 전달 가능하게 하는 기능\n      - 전역변수를 사용하는것과 비슷하지만, JS의 클로저를 활용하는 개념과 유사하다고 본다.\n      - 만약 상위에 Context가 있고 하위에서 Context를 선언할 시 하위의 Context를 참조함\n      - Context를 사용 시 따로 지정된 context를 참조하는게 아니라 문맥상 가장 가까운 위치의 context를 참조하기 때문에 만약, 하위에서 context를 사용 시 이를 참조하게 된다.\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      //React.createContext(Context 생성)\n      const MyContext = React.createContext(defaultValue); //defaultValue : Provider를 찾지 못하였을 때 사용\n\n      //Context.Provider : Notiy역활 수행\n      <MyContext.Provider value={/* 어떤 값 */}/>; //value가 변경된 것을 알리는 역활(re-rendering 수행)\n\n      //Context.Consumer : 구독 역활 수행\n      <MyContext.Consumer>\n        {value => /* context 값을 이용한 렌더링 */} //value를 구독\n      </MyContext.Consumer>\n      ```\n\n      </details>\n\n4.  Custom Hook\n\n    - 상태관련 Logic을 컴포넌트 간 재사용하고 싶은데 고전적인 방식으로는 higher-order components와 render props 2가지 방식을 사용\n    - Custom Hook은 이를 대체\n    - 이름의 경우 'useOOO'과 같이 앞에 use를 붙여서 사용 시 linter 플러그인 사용 시 버그를 찾아준다.\n\n      <details>\n      <summary>사용 예시</summary>\n\n      ```javascript\n      import React, { useState, useEffect } from 'react';\n\n      function useFriendStatus(friendID) {\n        const [isOnline, setIsOnline] = useState(null);\n\n        function handleStatusChange(status) {\n          setIsOnline(status.isOnline);\n        }\n\n        useEffect(() => {\n          ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);\n          return () => {\n            ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);\n          };\n        });\n\n        return isOnline;\n      }\n\n      //각 함수에서 독립되게 호출되어 사용됨\n      function FriendStatus(props) {\n        const isOnline = useFriendStatus(props.friend.id);\n\n        if (isOnline === null) {\n          return 'Loading...';\n        }\n        return isOnline ? 'Online' : 'Offline';\n      }\n\n      function FriendListItem(props) {\n        const isOnline = useFriendStatus(props.friend.id);\n\n        return <li style={{ color: isOnline ? 'green' : 'black' }}>{props.friend.name}</li>;\n      }\n      ```\n\n      </details>\n\n### 규칙\n\n1. 최상위 에서만 호출해야함. 반복문, 조건문, 중첩된 함수에서는 사용 X\n\n   - useState, useEffect가 여러번 호출되어 Hook보장을 위해서 최상위에서만 쓰라는 것\n\n   - 작성한 순서대로 react는 읽어들임(순서보장)\n\n2. Custom Hook이 아닌 이상, React 함수 컴포넌트에서만 호출할 것\n\n### 기타\n\n1. useEffect vs useLayoutEffect\n   - useEffect는 브라우저 화면이 다 그려질때 까지 지연, 다음 렌더링이 발생하기 전에 발생하는 것을 보장. 레이아웃 배치&그리기 완료 후 발생\n   - 이를 대체하기 위해 useLayoutEffect가 존재, 이는 모든 DOM변경 후 동기적으로 발생. 브라우저가 화면 그리기 이전에 동기적으로 발생\n     - componentDidMount나 componentDidUpdate와 동일한 단계를 실행하게 된다는 것에 주의\n   - 먼저 useEffect사용 후 문제 시 useLayoutEffect 사용할 것, 서버 렌더링 단계에서는 모든 js다운 전까지 둘다 실행 되지 않는다.\n     - UI가 깨져보일 수 있는 것들은 조건부 렌더링이나 노출 지연할 것\n","excerpt":"React.js의 Hook에 대해서 학습 및 사용법 학습의 경우 공식 홈페이지를 참고하여 진행(공식홈페이지). React 버전 16.8.0이상, React Native 0.59이상에서 지원 등장 배경 기존 React에서 state…","fields":{"slug":"/React js Hook/"},"frontmatter":{"date":"Mar 06, 2020","title":"React.js Hook","tags":["React.js","Hook"]}}},{"node":{"rawMarkdownBody":"\n## JSP에서 Github autopush 환경 만들기\n\n### 개발환경\n\n- Server : Tomcat8\n- OS : window10\n\n### 구현\n\n- DB에 Data가 갱신될 때 마다 Github 저장소에 auto push 기능을 구현하고자 하였다.\n- 이를 위해서 우선적으로 bat파일을 만들어 jsp환경에서 성공적으로 DB에 Update 시 실행하도록 하였다.\n\n  <details>\n  <summary>batch 파일 코드</summary>\n\n  ```Shell\n    F: #batch파일이 존재하는 드라이브 위치\n    cd 'batch가 위치할 폴더 경로' #batch 파일이 위치 할 폴더 경로\n    git add . #git에 변경된 사항에 대해서 스테이징 한다.\n    git commit -m \"auto push(file upload)\" #commit실행\n    git push origin master #git 저장소에 push\n  ```\n\n</details>\n\n- jsp에서 Runtime의 exec함수를 사용하여 batch파일을 실행하도록 코드를 작성하였다.\n\n  ```java\n  <%@ page import=\"java.lang.Runtime\"%> //Runtime import\n\n  Process process = Runtime.getRuntime().exec(\"파일경로\");\n  process.waitFor(); //batch파일이 실행되기 까지 대기\n\n  //Option : 실행 결과에대해서 알고 싶은 경우 구현\n  BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));\n\n  String line = null;\n\n  while((line = br.readLine()) != null){\n      out.println(line);\n  }\n  br.close();\n  //Option 끝\n\n  process.destroy(); //완료된 프로세스 제거\n  ```\n\n### 이슈\n\n- batch파일을 터미널에서 실행 시 정상적으로 수행되었으나 jsp코드 상 실행 시 무한 loop가 걸리는 문제가 존재하였다. 이에 대하여 line별 실행 해본 결과 push과정에서 문제가 발생하였다.\n- 이와 관련된 문제를 찾아본 결과 권한 문제. 즉, 로그인 문제인걸로 방향을 잡고 SSH keys를 발급하여 GitHub 계정에 등록하였다. 그러나 문제가 해결되지 않았다.\n- 이와 관련된, 문제에 대해서 찾아도 나오지 않아 프로젝트 문제인걸로 방향을 잡고 새로운 저장소를 생성하여 실행하였으나 결과는 같았다. 그때, 실수로 branch를 새로 생성하였는데 이 후로 push 실행 시 수행되는 것을 확인하였다!😮\n- SSH Keys를 발급 후 push를 수행한 경우 자동적으로 권한 취득이 되어 아이디/패스워드 미입력이 되는줄 알았는데 아니었나보다...\n- 만약, 이와 같은 증상을 겪는사람이 있다면 SSH Keys등록 후 브랜치를 하나 생성해보길 바란다.\n\n### 참고 사이트\n\n- [Pushing to Git returning Error Code 403 fatal: HTTP request failed](https://stackoverflow.com/questions/7438313/pushing-to-git-returning-error-code-403-fatal-http-request-failed)\n","excerpt":"JSP에서 Github autopush 환경 만들기 개발환경 Server : Tomcat8 OS : window10 구현 DB에 Data가 갱신될 때 마다 Github 저장소에 auto push 기능을 구현하고자 하였다. 이를 위해서 우선적으로 bat…","fields":{"slug":"/JSP batch/"},"frontmatter":{"date":"Mar 04, 2020","title":"JSP에서 batch 실행하기","tags":["JSP","batch","github","autopush"]}}},{"node":{"rawMarkdownBody":"\n## split()함수에 Regex를 사용 시 \"\"값이 return되지 않는 문제\n\n고객이 네트워크 속도 문제로 인해 필요없는 파일을 load하지 않기로 하였다. 이에 대해서 특정 js파일을 load제외하였는데 그로인해 IE8에서 textsize를 계산할 때 다른점이 발견되었다. 이러한 부분을 조사 중 IE8에서 split()에 정규식 공백문자(\" \")를 사용 시 반환되는 배열에 empty string(\"\")값이 제외되는 문제가 발생하였다.\n\n<details>\n<summary>💡 String.split() syntax</summary>\n\n```javascript\nString.split([separator[, limit]])\nseparator : 끊을 문자 or 정규식\nlimit : 몇 개 까지 자를 지에 대한 숫자\n```\n\n</details>\n\n만약 \" ab c d e fg 123 \"와 같은 문자열이 있다고 하자. 이 문자열에 대하여 \" \" 공백문자를 기준으로 자르고자 한다. 그렇다면 split()함수에 \" \"공백을 인자로 사용 시 \"\"을 포함한 배열이 반환 될 것이다. 근데, 만약 정규식을 사용 한다면 어떻게 될까?\n\n보통 정규식을 사용 시 다음과 같이 사용을 할 것이다\n\n```javascript\nvar reg = /abc/;\nvar reg = new RegExp('abc');\n```\n\n두 방식의 차이는 컴파일 시점의 차이로 첫 번째 방식의 경우 스크립트가 load되는 시점에 컴파일 되며 두 번째의 경우는 정규식이 실행되는 시점에 컴파일 된다. 만약, 상수와 같이 고정된 조건에 대해서 사용하는 경우 첫 번째 방식을 사용하며, 조건이 변경되는 경우는 두 번째 방식을 사용하면 될 것이다.\n\n### 테스트\n\n실행결과의 경우 아래에서 확인 가능하며, 해당 파일은 GitHub 저장소에 업로드되어있다.([**저장소**](https://github.com/AnGwangHo/sampleFile))\n\n<iframe width=\"100%\" height=\"300\" src=\"https://angwangho.github.io/sampleFile/window_method/split.html\" frameborder=\"0\" allowfullscreen=\"\"></iframe>\n\n위 샘플에서 확인하였듯이 split()에 정규식을 사용하게 된다면 아래와 같이 empty stirng이 제외된 결과가 나올 것이다.\n\n```javascript\n//IE8 이하\n'   ab c d e   fg 123   '.split(' '); //[\"\", \"\", \"\", \"ab\", \"c\", \"d\", \"e\", \"\", \"\", \"fg\", \"123\", \"\", \"\", \"\"]\n'   ab c d e   fg 123   '.split(/\\s/); //[\"ab\", \"c\", \"d\", \"e\", \"fg\", \"123\"]\n```\n\n위 방식의 경우 동일하게 스페이스 문자를 기준으로 자르도록 하였다. 그러나 결과는 다르게 발생되었다. 문자열로 공백 문자를 인자로 준 경우 empty string값이 포함되어 배열이 반환되었으나 정규식을 사용한 경우 \"\"인 값들이 제외되고 배열이 반환되었다. 이를 해결하고자 다음과 같은 방안을 세우고 시도를 해보았다.\n\n### 해결방안\n\n1. ~~new RegExp(\"\\\\s\")를 사용~~\n   - \"\"값이 제외되어 반환\n2. ~~정규식 문법을 수정~~\n   - 다양한 방법으로 조건을 변경하였으나 \"\"값이 제외되어 반환되었다.  \n     ex) /(\\s)/, /[\\s\\xA0]/, / /g, /[ \\f\\n\\r\\t\\v]/, /\\u0020/(공백문자 유니코드)\n\n위와 같은 해결방안을 세우고 시도하였으나 \"\"값이 제외되고 반환되었다. 따로 해결이 가능한 부분이 없었으며 다음과 같은 결론을 내렸다.\n\n### 처리결과\n\n우선적으로 고객이 제외한 js파일에서 String.split함수에 대해서 오버라이딩이 되어있어 IE8이하에서 split(/\\s/)시 \"\"값이 포함된 배열이 반환되었다. 이러한 부분에 대해서 고객에게 split함수에 대해서 오버라이딩된 코드를 적용하도록 가이드하였다. 만약, 외부에서 IE8이하 브라우저를 지원해야하는 경우가 존재한다면 아래의 코드를 적용하면 된다.\n\n<details><summary>코드</summary>\n\n```javascript\n/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nvar split;\n\n// Avoid running twice; that would break the `nativeSplit` reference\nsplit =\n  split ||\n  (function(undef) {\n    var nativeSplit = String.prototype.split,\n      compliantExecNpcg = /()??/.exec('')[1] === undef, // NPCG: nonparticipating capturing group\n      self;\n\n    self = function(str, separator, limit) {\n      // If `separator` is not a regex, use `nativeSplit`\n      if (Object.prototype.toString.call(separator) !== '[object RegExp]') {\n        return nativeSplit.call(str, separator, limit);\n      }\n      var output = [],\n        flags =\n          (separator.ignoreCase ? 'i' : '') +\n          (separator.multiline ? 'm' : '') +\n          (separator.extended ? 'x' : '') + // Proposed for ES6\n          (separator.sticky ? 'y' : ''), // Firefox 3+\n        lastLastIndex = 0,\n        // Make `global` and avoid `lastIndex` issues by working with a copy\n        separator = new RegExp(separator.source, flags + 'g'),\n        separator2,\n        match,\n        lastIndex,\n        lastLength;\n      str += ''; // Type-convert\n      if (!compliantExecNpcg) {\n        // Doesn't need flags gy, but they don't hurt\n        separator2 = new RegExp('^' + separator.source + '$(?!\\\\s)', flags);\n      }\n      /* Values for `limit`, per the spec:\n       * If undefined: 4294967295 // Math.pow(2, 32) - 1\n       * If 0, Infinity, or NaN: 0\n       * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n       * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n       * If other: Type-convert, then use the above rules\n       */\n      limit =\n        limit === undef\n          ? -1 >>> 0 // Math.pow(2, 32) - 1\n          : limit >>> 0; // ToUint32(limit)\n      while ((match = separator.exec(str))) {\n        // `separator.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0].length;\n        if (lastIndex > lastLastIndex) {\n          output.push(str.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for\n          // nonparticipating capturing groups\n          if (!compliantExecNpcg && match.length > 1) {\n            match[0].replace(separator2, function() {\n              for (var i = 1; i < arguments.length - 2; i++) {\n                if (arguments[i] === undef) {\n                  match[i] = undef;\n                }\n              }\n            });\n          }\n          if (match.length > 1 && match.index < str.length) {\n            Array.prototype.push.apply(output, match.slice(1));\n          }\n          lastLength = match[0].length;\n          lastLastIndex = lastIndex;\n          if (output.length >= limit) {\n            break;\n          }\n        }\n        if (separator.lastIndex === match.index) {\n          separator.lastIndex++; // Avoid an infinite loop\n        }\n      }\n      if (lastLastIndex === str.length) {\n        if (lastLength || !separator.test('')) {\n          output.push('');\n        }\n      } else {\n        output.push(str.slice(lastLastIndex));\n      }\n      return output.length > limit ? output.slice(0, limit) : output;\n    };\n\n    // For convenience\n    String.prototype.split = function(separator, limit) {\n      return self(this, separator, limit);\n    };\n\n    return self;\n  })();\n```\n\n</details>\n\n### 참고자료\n\n1. 정규식 테스트 사이트\n\n   [Non breaking space - Regex Tester/Debugger](https://www.regextester.com/105851)\n\n2. MS 공식 사이트\n\n   [Regular Expression Syntax (Scripting)](<https://docs.microsoft.com/en-us/previous-versions//1400241x(v=vs.85)?redirectedfrom=MSDN>)\n\n3. split 함수 재정의코드\n\n   [JavaScript split Bugs: Fixed!](http://blog.stevenlevithan.com/archives/cross-browser-split)\n","excerpt":"split()함수에 Regex를 사용 시 \"\"값이 return되지 않는 문제 고객이 네트워크 속도 문제로 인해 필요없는 파일을 load하지 않기로 하였다. 이에 대해서 특정 js파일을 load제외하였는데 그로인해 IE8에서 textsize…","fields":{"slug":"/IE8-Split-Bug/"},"frontmatter":{"date":"Mar 03, 2020","title":"IE8 Split Bug","tags":["IE","Split","Browser Bug"]}}}]}},"pageContext":{}}}